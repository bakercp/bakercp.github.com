<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ofxLibav: AVOptions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ofxLibav
   </div>
   <div id="projectbrief">A small wrapper for libav.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__avoptions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AVOptions<div class="ingroups"><a class="el" href="group__lavu__data.html">Data Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__opt__eval__funcs"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opt__eval__funcs.html">Evaluating option strings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__opt__set__funcs"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opt__set__funcs.html">Option setting functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__opt__get__funcs"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opt__get__funcs.html">Option getting functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_option.html">AVOption</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga25801ba4fc9b5313eb33ec84e082dd72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#ga25801ba4fc9b5313eb33ec84e082dd72">AV_OPT_SEARCH_CHILDREN</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:ga25801ba4fc9b5313eb33ec84e082dd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa764998552a6f6f66a47ecd52b345caa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#gaa764998552a6f6f66a47ecd52b345caa">AV_OPT_SEARCH_FAKE_OBJ</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:gaa764998552a6f6f66a47ecd52b345caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa1b952fe722d2259743ba5a35ce47f46"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_a_v_option.html">AVOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#gaa1b952fe722d2259743ba5a35ce47f46">AVOption</a></td></tr>
<tr class="separator:gaa1b952fe722d2259743ba5a35ce47f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabd75aa30eb8ad6387672df9a1fa79444"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#gabd75aa30eb8ad6387672df9a1fa79444">AVOptionType</a> { <br/>
&#160;&#160;<b>AV_OPT_TYPE_FLAGS</b>, 
<b>AV_OPT_TYPE_INT</b>, 
<b>AV_OPT_TYPE_INT64</b>, 
<b>AV_OPT_TYPE_DOUBLE</b>, 
<br/>
&#160;&#160;<b>AV_OPT_TYPE_FLOAT</b>, 
<b>AV_OPT_TYPE_STRING</b>, 
<b>AV_OPT_TYPE_RATIONAL</b>, 
<a class="el" href="group__avoptions.html#ggabd75aa30eb8ad6387672df9a1fa79444a2689966edbe494482dfdfaa4efdf95d3">AV_OPT_TYPE_BINARY</a>, 
<br/>
&#160;&#160;<b>AV_OPT_TYPE_CONST</b> = 128
<br/>
 }</td></tr>
<tr class="separator:gabd75aa30eb8ad6387672df9a1fa79444"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf7394e27d34208b24af8bb4b4a11741b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#gaf7394e27d34208b24af8bb4b4a11741b">av_opt_show2</a> (void *obj, void *av_log_obj, int req_flags, int rej_flags)</td></tr>
<tr class="separator:gaf7394e27d34208b24af8bb4b4a11741b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ca968e9058b39b2da630ad0a091bdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#gad4ca968e9058b39b2da630ad0a091bdb">av_opt_set_defaults</a> (void *s)</td></tr>
<tr class="separator:gad4ca968e9058b39b2da630ad0a091bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48669d1326f7d47ef39e5702e34abd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#gab48669d1326f7d47ef39e5702e34abd2">av_set_options_string</a> (void *ctx, const char *opts, const char *key_val_sep, const char *pairs_sep)</td></tr>
<tr class="separator:gab48669d1326f7d47ef39e5702e34abd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14db824af52baf8181406e98d116097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#gac14db824af52baf8181406e98d116097">av_opt_free</a> (void *obj)</td></tr>
<tr class="separator:gac14db824af52baf8181406e98d116097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1436a3afc8dbc70ed9e70c8287dcc766"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#ga1436a3afc8dbc70ed9e70c8287dcc766">av_opt_flag_is_set</a> (void *obj, const char *field_name, const char *flag_name)</td></tr>
<tr class="separator:ga1436a3afc8dbc70ed9e70c8287dcc766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1a88e8f152d7835f111b1ef8813fb2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf1a88e8f152d7835f111b1ef8813fb2e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>av_opt_set_dict</b> (void *obj, struct AVDictionary **options)</td></tr>
<tr class="separator:gaf1a88e8f152d7835f111b1ef8813fb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae31ae7fb20113b00108d0ecf53f25664"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_a_v_option.html">AVOption</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#gae31ae7fb20113b00108d0ecf53f25664">av_opt_find</a> (void *obj, const char *name, const char *unit, int opt_flags, int search_flags)</td></tr>
<tr class="separator:gae31ae7fb20113b00108d0ecf53f25664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e121fd0b44b34e31756f4fe848d29a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_a_v_option.html">AVOption</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#ga3e121fd0b44b34e31756f4fe848d29a7">av_opt_find2</a> (void *obj, const char *name, const char *unit, int opt_flags, int search_flags, void **target_obj)</td></tr>
<tr class="separator:ga3e121fd0b44b34e31756f4fe848d29a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78edbb7da1fdc8626d8a52f8ab7e7a0c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_a_v_option.html">AVOption</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#ga78edbb7da1fdc8626d8a52f8ab7e7a0c">av_opt_next</a> (void *obj, const <a class="el" href="struct_a_v_option.html">AVOption</a> *prev)</td></tr>
<tr class="separator:ga78edbb7da1fdc8626d8a52f8ab7e7a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacce30022d2e99c7b9309d3ad3345f69"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#gaacce30022d2e99c7b9309d3ad3345f69">av_opt_child_next</a> (void *obj, void *prev)</td></tr>
<tr class="separator:gaacce30022d2e99c7b9309d3ad3345f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee1f425013a0f861a40a72d80f189b1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_a_v_class.html">AVClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avoptions.html#gadee1f425013a0f861a40a72d80f189b1">av_opt_child_class_next</a> (const <a class="el" href="struct_a_v_class.html">AVClass</a> *parent, const <a class="el" href="struct_a_v_class.html">AVClass</a> *prev)</td></tr>
<tr class="separator:gadee1f425013a0f861a40a72d80f189b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>AVOptions provide a generic system to declare options on arbitrary structs ("objects"). An option can have a help text, a type and a range of possible values. Options may then be enumerated, read and written to.</p>
<h1><a class="anchor" id="avoptions_implement"></a>
Implementing AVOptions</h1>
<p>This section describes how to add AVOptions capabilities to a struct.</p>
<p>All AVOptions-related information is stored in an <a class="el" href="struct_a_v_class.html">AVClass</a>. Therefore the first member of the struct must be a pointer to an <a class="el" href="struct_a_v_class.html">AVClass</a> describing it. The option field of the <a class="el" href="struct_a_v_class.html">AVClass</a> must be set to a NULL-terminated static array of AVOptions. Each <a class="el" href="struct_a_v_option.html">AVOption</a> must have a non-empty name, a type, a default value and for number-type AVOptions also a range of allowed values. It must also declare an offset in bytes from the start of the struct, where the field associated with this <a class="el" href="struct_a_v_option.html">AVOption</a> is located. Other fields in the <a class="el" href="struct_a_v_option.html">AVOption</a> struct should also be set when applicable, but are not required.</p>
<p>The following example illustrates an AVOptions-enabled struct: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>test_struct {</div>
<div class="line">    <a class="code" href="struct_a_v_class.html">AVClass</a> *<span class="keyword">class</span>;</div>
<div class="line">    <span class="keywordtype">int</span>      int_opt;</div>
<div class="line">    <span class="keywordtype">char</span>    *str_opt;</div>
<div class="line">    uint8_t *bin_opt;</div>
<div class="line">    <span class="keywordtype">int</span>      bin_len;</div>
<div class="line">} test_struct;</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_a_v_option.html">AVOption</a> options[] = {</div>
<div class="line">  { <span class="stringliteral">&quot;test_int&quot;</span>, <span class="stringliteral">&quot;This is a test option of int type.&quot;</span>, offsetof(test_struct, int_opt),</div>
<div class="line">    AV_OPT_TYPE_INT, { .i64 = -1 }, INT_MIN, INT_MAX },</div>
<div class="line">  { <span class="stringliteral">&quot;test_str&quot;</span>, <span class="stringliteral">&quot;This is a test option of string type.&quot;</span>, offsetof(test_struct, str_opt),</div>
<div class="line">    AV_OPT_TYPE_STRING },</div>
<div class="line">  { <span class="stringliteral">&quot;test_bin&quot;</span>, <span class="stringliteral">&quot;This is a test option of binary type.&quot;</span>, offsetof(test_struct, bin_opt),</div>
<div class="line">    <a class="code" href="group__avoptions.html#ggabd75aa30eb8ad6387672df9a1fa79444a2689966edbe494482dfdfaa4efdf95d3">AV_OPT_TYPE_BINARY</a> },</div>
<div class="line">  { NULL },</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_a_v_class.html">AVClass</a> test_class = {</div>
<div class="line">    .<a class="code" href="struct_a_v_class.html#aa8883e113a3f2965abd008f7667db7eb">class_name</a> = <span class="stringliteral">&quot;test class&quot;</span>,</div>
<div class="line">    .item_name  = av_default_item_name,</div>
<div class="line">    .option     = options,</div>
<div class="line">    .version    = LIBAVUTIL_VERSION_INT,</div>
<div class="line">};</div>
</div><!-- fragment --><p>Next, when allocating your struct, you must ensure that the <a class="el" href="struct_a_v_class.html">AVClass</a> pointer is set to the correct value. Then, <a class="el" href="group__avoptions.html#gad4ca968e9058b39b2da630ad0a091bdb">av_opt_set_defaults()</a> must be called to initialize defaults. After that the struct is ready to be used with the AVOptions API.</p>
<p>When cleaning up, you may use the <a class="el" href="group__avoptions.html#gac14db824af52baf8181406e98d116097">av_opt_free()</a> function to automatically free all the allocated string and binary options.</p>
<p>Continuing with the above example:</p>
<div class="fragment"><div class="line">test_struct *alloc_test_struct(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    test_struct *ret = <a class="code" href="group__lavu__mem.html#gacbca30ebc510a7e4156d66e7aceb2dc8">av_malloc</a>(<span class="keyword">sizeof</span>(*ret));</div>
<div class="line">    ret-&gt;class = &amp;test_class;</div>
<div class="line">    <a class="code" href="group__avoptions.html#gad4ca968e9058b39b2da630ad0a091bdb">av_opt_set_defaults</a>(ret);</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> free_test_struct(test_struct **foo)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__avoptions.html#gac14db824af52baf8181406e98d116097">av_opt_free</a>(*foo);</div>
<div class="line">    <a class="code" href="group__lavu__mem.html#ga0cc84043ea2167ad005c86e11d0bcdba">av_freep</a>(foo);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="avoptions_implement_nesting"></a>
Nesting</h2>
<p>It may happen that an AVOptions-enabled struct contains another AVOptions-enabled struct as a member (e.g. <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> in libavcodec exports generic options, while its priv_data field exports codec-specific options). In such a case, it is possible to set up the parent struct to export a child's options. To do that, simply implement <a class="el" href="struct_a_v_class.html#af13472aa40bca9eaad0d5b4ee4c00cab">AVClass.child_next()</a> and <a class="el" href="struct_a_v_class.html#a0f4a274042064e70970f1be345c43343">AVClass.child_class_next()</a> in the parent struct's <a class="el" href="struct_a_v_class.html">AVClass</a>. Assuming that the test_struct from above now also contains a child_struct field:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>child_struct {</div>
<div class="line">    <a class="code" href="struct_a_v_class.html">AVClass</a> *<span class="keyword">class</span>;</div>
<div class="line">    <span class="keywordtype">int</span> flags_opt;</div>
<div class="line">} child_struct;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_a_v_option.html">AVOption</a> child_opts[] = {</div>
<div class="line">    { <span class="stringliteral">&quot;test_flags&quot;</span>, <span class="stringliteral">&quot;This is a test option of flags type.&quot;</span>,</div>
<div class="line">      offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX },</div>
<div class="line">    { NULL },</div>
<div class="line">};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_a_v_class.html">AVClass</a> child_class = {</div>
<div class="line">    .<a class="code" href="struct_a_v_class.html#aa8883e113a3f2965abd008f7667db7eb">class_name</a> = <span class="stringliteral">&quot;child class&quot;</span>,</div>
<div class="line">    .item_name  = av_default_item_name,</div>
<div class="line">    .option     = child_opts,</div>
<div class="line">    .version    = LIBAVUTIL_VERSION_INT,</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> *child_next(<span class="keywordtype">void</span> *obj, <span class="keywordtype">void</span> *prev)</div>
<div class="line">{</div>
<div class="line">    test_struct *t = obj;</div>
<div class="line">    <span class="keywordflow">if</span> (!prev &amp;&amp; t-&gt;child_struct)</div>
<div class="line">        <span class="keywordflow">return</span> t-&gt;child_struct;</div>
<div class="line">    <span class="keywordflow">return</span> NULL</div>
<div class="line">}</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="struct_a_v_class.html">AVClass</a> child_class_next(<span class="keyword">const</span> <a class="code" href="struct_a_v_class.html">AVClass</a> *prev)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> prev ? NULL : &amp;child_class;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Putting child_next() and child_class_next() as defined above into test_class will now make child_struct's options accessible through test_struct (again, proper setup as described above needs to be done on child_struct right after it is created).</p>
<p>From the above example it might not be clear why both child_next() and child_class_next() are needed. The distinction is that child_next() iterates over actually existing objects, while child_class_next() iterates over all possible child classes. E.g. if an <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> was initialized to use a codec which has private options, then its child_next() will return AVCodecContext.priv_data and finish iterating. OTOH child_class_next() on <a class="el" href="struct_a_v_codec_context.html#a90622d3af2a9abba986a1c9f7ca21b16">AVCodecContext.av_class</a> will iterate over all available codecs with private options.</p>
<h2><a class="anchor" id="avoptions_implement_named_constants"></a>
Named constants</h2>
<p>It is possible to create named constants for options. Simply set the unit field of the option the constants should apply to to a string and create the constants themselves as options of type AV_OPT_TYPE_CONST with their unit field set to the same string. Their default_val field should contain the value of the named constant. For example, to add some named constants for the test_flags option above, put the following into the child_opts array: </p>
<div class="fragment"><div class="line">{ <span class="stringliteral">&quot;test_flags&quot;</span>, <span class="stringliteral">&quot;This is a test option of flags type.&quot;</span>,</div>
<div class="line">  offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX, <span class="stringliteral">&quot;test_unit&quot;</span> },</div>
<div class="line">{ <span class="stringliteral">&quot;flag1&quot;</span>, <span class="stringliteral">&quot;This is a flag with value 16&quot;</span>, 0, AV_OPT_TYPE_CONST, { .i64 = 16 }, 0, 0, <span class="stringliteral">&quot;test_unit&quot;</span> },</div>
</div><!-- fragment --><h1><a class="anchor" id="avoptions_use"></a>
Using AVOptions</h1>
<p>This section deals with accessing options in an AVOptions-enabled struct. Such structs in Libav are e.g. <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> in libavcodec or <a class="el" href="struct_a_v_format_context.html">AVFormatContext</a> in libavformat.</p>
<h2><a class="anchor" id="avoptions_use_examine"></a>
Examining AVOptions</h2>
<p>The basic functions for examining options are <a class="el" href="group__avoptions.html#ga78edbb7da1fdc8626d8a52f8ab7e7a0c">av_opt_next()</a>, which iterates over all options defined for one object, and <a class="el" href="group__avoptions.html#gae31ae7fb20113b00108d0ecf53f25664">av_opt_find()</a>, which searches for an option with the given name.</p>
<p>The situation is more complicated with nesting. An AVOptions-enabled struct may have AVOptions-enabled children. Passing the AV_OPT_SEARCH_CHILDREN flag to <a class="el" href="group__avoptions.html#gae31ae7fb20113b00108d0ecf53f25664">av_opt_find()</a> will make the function search children recursively.</p>
<p>For enumerating there are basically two cases. The first is when you want to get all options that may potentially exist on the struct and its children (e.g. when constructing documentation). In that case you should call <a class="el" href="group__avoptions.html#gadee1f425013a0f861a40a72d80f189b1">av_opt_child_class_next()</a> recursively on the parent struct's <a class="el" href="struct_a_v_class.html">AVClass</a>. The second case is when you have an already initialized struct with all its children and you want to get all options that can be actually written or read from it. In that case you should call <a class="el" href="group__avoptions.html#gaacce30022d2e99c7b9309d3ad3345f69">av_opt_child_next()</a> recursively (and <a class="el" href="group__avoptions.html#ga78edbb7da1fdc8626d8a52f8ab7e7a0c">av_opt_next()</a> on each result).</p>
<h2><a class="anchor" id="avoptions_use_get_set"></a>
Reading and writing AVOptions</h2>
<p>When setting options, you often have a string read directly from the user. In such a case, simply passing it to av_opt_set() is enough. For non-string type options, av_opt_set() will parse the string according to the option type.</p>
<p>Similarly <a class="el" href="group__opt__get__funcs.html#gaf31144e60f9ce89dbe8cbea57a0b232c">av_opt_get()</a> will read any option type and convert it to a string which will be returned. Do not forget that the string is allocated, so you have to free it with <a class="el" href="group__lavu__mem.html#ga0c9096f498624c525aa2315b8a20c411">av_free()</a>.</p>
<p>In some cases it may be more convenient to put all options into an AVDictionary and call av_opt_set_dict() on it. A specific case of this are the format/codec open functions in lavf/lavc which take a dictionary filled with option as a parameter. This allows to set some options that cannot be set otherwise, since e.g. the input file format is not known before the file is actually opened. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga25801ba4fc9b5313eb33ec84e082dd72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AV_OPT_SEARCH_CHILDREN&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search in possible children of the given object first. </p>

</div>
</div>
<a class="anchor" id="gaa764998552a6f6f66a47ecd52b345caa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AV_OPT_SEARCH_FAKE_OBJ&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The obj passed to <a class="el" href="group__avoptions.html#gae31ae7fb20113b00108d0ecf53f25664">av_opt_find()</a> is fake &ndash; only a double pointer to <a class="el" href="struct_a_v_class.html">AVClass</a> instead of a required pointer to a struct containing <a class="el" href="struct_a_v_class.html">AVClass</a>. This is useful for searching for options without needing to allocate the corresponding object. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaa1b952fe722d2259743ba5a35ce47f46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_a_v_option.html">AVOption</a>  <a class="el" href="struct_a_v_option.html">AVOption</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_a_v_option.html">AVOption</a> </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gabd75aa30eb8ad6387672df9a1fa79444"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__avoptions.html#gabd75aa30eb8ad6387672df9a1fa79444">AVOptionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggabd75aa30eb8ad6387672df9a1fa79444a2689966edbe494482dfdfaa4efdf95d3"></a>AV_OPT_TYPE_BINARY</em>&#160;</td><td class="fielddoc">
<p>offset must point to a pointer immediately followed by an int for the length </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gadee1f425013a0f861a40a72d80f189b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_a_v_class.html">AVClass</a>* av_opt_child_class_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_v_class.html">AVClass</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_v_class.html">AVClass</a> *&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over potential AVOptions-enabled children of parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>result of a previous call to this function or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a_v_class.html">AVClass</a> corresponding to next potential child or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaacce30022d2e99c7b9309d3ad3345f69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* av_opt_child_next </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over AVOptions-enabled children of obj.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>result of a previous call to this function or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next AVOptions-enabled child or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gae31ae7fb20113b00108d0ecf53f25664"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_a_v_option.html">AVOption</a>* av_opt_find </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look for an option in an object. Consider only options which have all the specified flags set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to a struct whose first element is a pointer to an <a class="el" href="struct_a_v_class.html">AVClass</a>. Alternatively a double pointer to an <a class="el" href="struct_a_v_class.html">AVClass</a>, if AV_OPT_SEARCH_FAKE_OBJ search flag is set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the option to look for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit</td><td>When searching for named constants, name of the unit it belongs to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opt_flags</td><td>Find only options with all the specified flags set (AV_OPT_FLAG). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">search_flags</td><td>A combination of AV_OPT_SEARCH_*.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the option found, or NULL if no option was found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable directly with av_set_string3(). Use special calls which take an options AVDictionary (e.g. <a class="el" href="group__lavf__decoding.html#ga10a404346c646e4ab58f4ed798baca32">avformat_open_input()</a>) to set options found with this flag. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e121fd0b44b34e31756f4fe848d29a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_a_v_option.html">AVOption</a>* av_opt_find2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>target_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look for an option in an object. Consider only options which have all the specified flags set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to a struct whose first element is a pointer to an <a class="el" href="struct_a_v_class.html">AVClass</a>. Alternatively a double pointer to an <a class="el" href="struct_a_v_class.html">AVClass</a>, if AV_OPT_SEARCH_FAKE_OBJ search flag is set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the option to look for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit</td><td>When searching for named constants, name of the unit it belongs to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opt_flags</td><td>Find only options with all the specified flags set (AV_OPT_FLAG). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">search_flags</td><td>A combination of AV_OPT_SEARCH_*. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">target_obj</td><td>if non-NULL, an object to which the option belongs will be written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present in search_flags. This parameter is ignored if search_flags contain AV_OPT_SEARCH_FAKE_OBJ.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the option found, or NULL if no option was found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1436a3afc8dbc70ed9e70c8287dcc766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_opt_flag_is_set </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>flag_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a particular flag is set in a flags field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the flag field option </td></tr>
    <tr><td class="paramname">flag_name</td><td>the name of the flag to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the flag is set, zero if the flag isn't set, isn't of the right type, or the flags field doesn't exist. </dd></dl>

</div>
</div>
<a class="anchor" id="gac14db824af52baf8181406e98d116097"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_opt_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free all string and binary options in obj. </p>

</div>
</div>
<a class="anchor" id="ga78edbb7da1fdc8626d8a52f8ab7e7a0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_a_v_option.html">AVOption</a>* av_opt_next </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_v_option.html">AVOption</a> *&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over all AVOptions belonging to obj.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>an AVOptions-enabled struct or a double pointer to an <a class="el" href="struct_a_v_class.html">AVClass</a> describing it. </td></tr>
    <tr><td class="paramname">prev</td><td>result of the previous call to <a class="el" href="group__avoptions.html#ga78edbb7da1fdc8626d8a52f8ab7e7a0c">av_opt_next()</a> on this object or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next <a class="el" href="struct_a_v_option.html">AVOption</a> or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gad4ca968e9058b39b2da630ad0a091bdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_opt_set_defaults </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the values of all <a class="el" href="struct_a_v_option.html">AVOption</a> fields to their default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>an AVOption-enabled struct (its first member must be a pointer to <a class="el" href="struct_a_v_class.html">AVClass</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7394e27d34208b24af8bb4b4a11741b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_opt_show2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>av_log_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>req_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rej_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Show the obj options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req_flags</td><td>requested flags for the options to show. Show only the options for which it is opt-&gt;flags &amp; req_flags. </td></tr>
    <tr><td class="paramname">rej_flags</td><td>rejected flags for the options to show. Show only the options for which it is !(opt-&gt;flags &amp; req_flags). </td></tr>
    <tr><td class="paramname">av_log_obj</td><td>log context to use for showing the options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab48669d1326f7d47ef39e5702e34abd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_set_options_string </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_val_sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pairs_sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the key/value pairs list in opts. For each key/value pair found, stores the value in the field in ctx that is named like the key. ctx must be an <a class="el" href="struct_a_v_class.html">AVClass</a> context, storing is done using AVOptions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_val_sep</td><td>a 0-terminated list of characters used to separate key from value </td></tr>
    <tr><td class="paramname">pairs_sep</td><td>a 0-terminated list of characters used to separate two pairs from each other </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of successfully set key/value pairs, or a negative value corresponding to an AVERROR code in case of error: AVERROR(EINVAL) if opts cannot be parsed, the error code issued by av_set_string3() if a key/value pair cannot be set </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Jan 11 2014 18:32:16 for ofxLibav by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
