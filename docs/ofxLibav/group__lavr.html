<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ofxLibav: Libavresample</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ofxLibav
   </div>
   <div id="projectbrief">A small wrapper for libav.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__lavr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Libavresample</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:avresample_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avresample_8h.html">avresample.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaee1afc173c8d1eefe0e1d8a881b7df26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee1afc173c8d1eefe0e1d8a881b7df26"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AVRESAMPLE_MAX_CHANNELS</b>&#160;&#160;&#160;32</td></tr>
<tr class="separator:gaee1afc173c8d1eefe0e1d8a881b7df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gabe4ee61779da95d51dff716ef5b275a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabe4ee61779da95d51dff716ef5b275a3"></a>
typedef struct <br class="typebreak"/>
AVAudioResampleContext&#160;</td><td class="memItemRight" valign="bottom"><b>AVAudioResampleContext</b></td></tr>
<tr class="separator:gabe4ee61779da95d51dff716ef5b275a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaaaa652e3ad8554a0dca126e8571735dd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#gaaaa652e3ad8554a0dca126e8571735dd">AVMixCoeffType</a> { <b>AV_MIX_COEFF_TYPE_Q8</b>, 
<a class="el" href="group__lavr.html#ggaaaa652e3ad8554a0dca126e8571735ddaf459c8599c850abd5d0308cd8609af68">AV_MIX_COEFF_TYPE_Q15</a>, 
<a class="el" href="group__lavr.html#ggaaaa652e3ad8554a0dca126e8571735dda5d6c3ee92cc045714ac2ec4c83588841">AV_MIX_COEFF_TYPE_FLT</a>, 
<a class="el" href="group__lavr.html#ggaaaa652e3ad8554a0dca126e8571735dda2672ba31292b1fb0a861b035466964a9">AV_MIX_COEFF_TYPE_NB</a>
 }</td></tr>
<tr class="separator:gaaaa652e3ad8554a0dca126e8571735dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3813087032c02f1e84f0ca2962b09400"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga3813087032c02f1e84f0ca2962b09400">AVResampleFilterType</a> { <a class="el" href="group__lavr.html#gga3813087032c02f1e84f0ca2962b09400ac8d3b66c4c4bd02418ce0b882fb7d4fa">AV_RESAMPLE_FILTER_TYPE_CUBIC</a>, 
<a class="el" href="group__lavr.html#gga3813087032c02f1e84f0ca2962b09400ace0cbc5bda3d6fa26b054b2fa7702886">AV_RESAMPLE_FILTER_TYPE_BLACKMAN_NUTTALL</a>, 
<a class="el" href="group__lavr.html#gga3813087032c02f1e84f0ca2962b09400af552d08855b8a5f4b46f6328633c8f1f">AV_RESAMPLE_FILTER_TYPE_KAISER</a>
 }</td></tr>
<tr class="separator:ga3813087032c02f1e84f0ca2962b09400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga302491313b02acca1a822249caa8cb10"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga302491313b02acca1a822249caa8cb10">AVResampleDitherMethod</a> { <br/>
&#160;&#160;<a class="el" href="group__lavr.html#gga302491313b02acca1a822249caa8cb10a4f892b254f02b3ebf775169f786e966b">AV_RESAMPLE_DITHER_NONE</a>, 
<a class="el" href="group__lavr.html#gga302491313b02acca1a822249caa8cb10a6e6841e6042d8059db5fdebe67d783ad">AV_RESAMPLE_DITHER_RECTANGULAR</a>, 
<a class="el" href="group__lavr.html#gga302491313b02acca1a822249caa8cb10a4d9b50692d2a3cdf6c3cfeb7f14ccfc6">AV_RESAMPLE_DITHER_TRIANGULAR</a>, 
<a class="el" href="group__lavr.html#gga302491313b02acca1a822249caa8cb10a261d5a5101aeff5e7ff5813787481bd6">AV_RESAMPLE_DITHER_TRIANGULAR_HP</a>, 
<br/>
&#160;&#160;<a class="el" href="group__lavr.html#gga302491313b02acca1a822249caa8cb10aa1abacc1c6e8c448959bc49316b8f566">AV_RESAMPLE_DITHER_TRIANGULAR_NS</a>, 
<a class="el" href="group__lavr.html#gga302491313b02acca1a822249caa8cb10ac9e29d7f4af2590ba9a59429d88d57c0">AV_RESAMPLE_DITHER_NB</a>
<br/>
 }</td></tr>
<tr class="separator:ga302491313b02acca1a822249caa8cb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaedabbb0590c33b7b9ce1ce213629dd3e"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#gaedabbb0590c33b7b9ce1ce213629dd3e">avresample_version</a> (void)</td></tr>
<tr class="separator:gaedabbb0590c33b7b9ce1ce213629dd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59d94ba578f9d7a90fd5d82ee6f361b4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga59d94ba578f9d7a90fd5d82ee6f361b4">avresample_configuration</a> (void)</td></tr>
<tr class="separator:ga59d94ba578f9d7a90fd5d82ee6f361b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e3794756514c6ccf42580c2a840d16c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga7e3794756514c6ccf42580c2a840d16c">avresample_license</a> (void)</td></tr>
<tr class="separator:ga7e3794756514c6ccf42580c2a840d16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40d8eeb3181386e30e5b02289e469a73"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_a_v_class.html">AVClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga40d8eeb3181386e30e5b02289e469a73">avresample_get_class</a> (void)</td></tr>
<tr class="separator:ga40d8eeb3181386e30e5b02289e469a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1bcb7a35446a07ce330a0ca2b38b72"><td class="memItemLeft" align="right" valign="top">AVAudioResampleContext *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga5b1bcb7a35446a07ce330a0ca2b38b72">avresample_alloc_context</a> (void)</td></tr>
<tr class="separator:ga5b1bcb7a35446a07ce330a0ca2b38b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc59c68689be880494ff24d10fd85143"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#gafc59c68689be880494ff24d10fd85143">avresample_open</a> (AVAudioResampleContext *avr)</td></tr>
<tr class="separator:gafc59c68689be880494ff24d10fd85143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30751a8c6923418a090281669362bf79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga30751a8c6923418a090281669362bf79">avresample_close</a> (AVAudioResampleContext *avr)</td></tr>
<tr class="separator:ga30751a8c6923418a090281669362bf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0782fe9a331b823c6d0dda5dbc63a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga1d0782fe9a331b823c6d0dda5dbc63a5">avresample_free</a> (AVAudioResampleContext **avr)</td></tr>
<tr class="separator:ga1d0782fe9a331b823c6d0dda5dbc63a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga496a46260f4a5f5854ecc21f0f0011c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga496a46260f4a5f5854ecc21f0f0011c8">avresample_build_matrix</a> (uint64_t in_layout, uint64_t out_layout, double center_mix_level, double surround_mix_level, double lfe_mix_level, int normalize, double *matrix, int stride, enum AVMatrixEncoding matrix_encoding)</td></tr>
<tr class="separator:ga496a46260f4a5f5854ecc21f0f0011c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d920b2dd1af265d7186a33f60e08e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga74d920b2dd1af265d7186a33f60e08e0">avresample_get_matrix</a> (AVAudioResampleContext *avr, double *matrix, int stride)</td></tr>
<tr class="separator:ga74d920b2dd1af265d7186a33f60e08e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3311c71aa573523c04882809143a9107"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga3311c71aa573523c04882809143a9107">avresample_set_matrix</a> (AVAudioResampleContext *avr, const double *matrix, int stride)</td></tr>
<tr class="separator:ga3311c71aa573523c04882809143a9107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3b3ffa44345e07babdd69267527cfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#gafc3b3ffa44345e07babdd69267527cfc">avresample_set_channel_mapping</a> (AVAudioResampleContext *avr, const int *channel_map)</td></tr>
<tr class="separator:gafc3b3ffa44345e07babdd69267527cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c7722a7b56ed3c4a44174611316d6ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga2c7722a7b56ed3c4a44174611316d6ab">avresample_set_compensation</a> (AVAudioResampleContext *avr, int sample_delta, int compensation_distance)</td></tr>
<tr class="separator:ga2c7722a7b56ed3c4a44174611316d6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga396ac8bcc2959dcedad01f91bab8145e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga396ac8bcc2959dcedad01f91bab8145e">avresample_convert</a> (AVAudioResampleContext *avr, uint8_t **output, int out_plane_size, int out_samples, uint8_t **input, int in_plane_size, int in_samples)</td></tr>
<tr class="separator:ga396ac8bcc2959dcedad01f91bab8145e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66240ec48b20c7a688ea0cd5fae6db15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga66240ec48b20c7a688ea0cd5fae6db15">avresample_get_delay</a> (AVAudioResampleContext *avr)</td></tr>
<tr class="separator:ga66240ec48b20c7a688ea0cd5fae6db15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed549e1e347ab11bb81883b9ce6bca2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#ga1ed549e1e347ab11bb81883b9ce6bca2">avresample_available</a> (AVAudioResampleContext *avr)</td></tr>
<tr class="separator:ga1ed549e1e347ab11bb81883b9ce6bca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae115c3f6edea41ae634583737bc554f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavr.html#gae115c3f6edea41ae634583737bc554f9">avresample_read</a> (AVAudioResampleContext *avr, uint8_t **output, int nb_samples)</td></tr>
<tr class="separator:gae115c3f6edea41ae634583737bc554f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Libavresample (lavr) is a library that handles audio resampling, sample format conversion and mixing.</p>
<p>Interaction with lavr is done through AVAudioResampleContext, which is allocated with <a class="el" href="group__lavr.html#ga5b1bcb7a35446a07ce330a0ca2b38b72">avresample_alloc_context()</a>. It is opaque, so all parameters must be set with the <a class="el" href="group__avoptions.html">AVOptions</a> API.</p>
<p>For example the following code will setup conversion from planar float sample format to interleaved signed 16-bit integer, downsampling from 48kHz to 44.1kHz and downmixing from 5.1 channels to stereo (using the default mixing matrix): </p>
<div class="fragment"><div class="line">AVAudioResampleContext *avr = <a class="code" href="group__lavr.html#ga5b1bcb7a35446a07ce330a0ca2b38b72">avresample_alloc_context</a>();</div>
<div class="line">av_opt_set_int(avr, <span class="stringliteral">&quot;in_channel_layout&quot;</span>,  AV_CH_LAYOUT_5POINT1, 0);</div>
<div class="line">av_opt_set_int(avr, <span class="stringliteral">&quot;out_channel_layout&quot;</span>, AV_CH_LAYOUT_STEREO,  0);</div>
<div class="line">av_opt_set_int(avr, <span class="stringliteral">&quot;in_sample_rate&quot;</span>,     48000,                0);</div>
<div class="line">av_opt_set_int(avr, <span class="stringliteral">&quot;out_sample_rate&quot;</span>,    44100,                0);</div>
<div class="line">av_opt_set_int(avr, <span class="stringliteral">&quot;in_sample_fmt&quot;</span>,      AV_SAMPLE_FMT_FLTP,   0);</div>
<div class="line">av_opt_set_int(avr, <span class="stringliteral">&quot;out_sample_fmt&quot;</span>,     AV_SAMPLE_FMT_S16,    0);</div>
</div><!-- fragment --><p>Once the context is initialized, it must be opened with <a class="el" href="group__lavr.html#gafc59c68689be880494ff24d10fd85143">avresample_open()</a>. If you need to change the conversion parameters, you must close the context with <a class="el" href="group__lavr.html#ga30751a8c6923418a090281669362bf79">avresample_close()</a>, change the parameters as described above, then reopen it again.</p>
<p>The conversion itself is done by repeatedly calling <a class="el" href="group__lavr.html#ga396ac8bcc2959dcedad01f91bab8145e">avresample_convert()</a>. Note that the samples may get buffered in two places in lavr. The first one is the output FIFO, where the samples end up if the output buffer is not large enough. The data stored in there may be retrieved at any time with <a class="el" href="group__lavr.html#gae115c3f6edea41ae634583737bc554f9">avresample_read()</a>. The second place is the resampling delay buffer, applicable only when resampling is done. The samples in it require more input before they can be processed. Their current amount is returned by <a class="el" href="group__lavr.html#ga66240ec48b20c7a688ea0cd5fae6db15">avresample_get_delay()</a>. At the end of conversion the resampling buffer can be flushed by calling <a class="el" href="group__lavr.html#ga396ac8bcc2959dcedad01f91bab8145e">avresample_convert()</a> with NULL input.</p>
<p>The following code demonstrates the conversion loop assuming the parameters from above and caller-defined functions get_input() and handle_output(): </p>
<div class="fragment"><div class="line">uint8_t **input;</div>
<div class="line"><span class="keywordtype">int</span> in_linesize, in_samples;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span> (get_input(&amp;input, &amp;in_linesize, &amp;in_samples)) {</div>
<div class="line">    uint8_t *output</div>
<div class="line">    <span class="keywordtype">int</span> out_linesize;</div>
<div class="line">    <span class="keywordtype">int</span> out_samples = <a class="code" href="group__lavr.html#ga1ed549e1e347ab11bb81883b9ce6bca2">avresample_available</a>(avr) +</div>
<div class="line">                      <a class="code" href="group__lavu__math.html#gad686ab94939ed4c65218309e94bdca72">av_rescale_rnd</a>(<a class="code" href="group__lavr.html#ga66240ec48b20c7a688ea0cd5fae6db15">avresample_get_delay</a>(avr) +</div>
<div class="line">                                     in_samples, 44100, 48000, <a class="code" href="group__lavu__math.html#gga921d656eaf2c4d6800a734a13af021d0aa1d28e08e2f8b49b256e056f93038c1a">AV_ROUND_UP</a>);</div>
<div class="line">    av_samples_alloc(&amp;output, &amp;out_linesize, 2, out_samples,</div>
<div class="line">                     AV_SAMPLE_FMT_S16, 0);</div>
<div class="line">    out_samples = <a class="code" href="group__lavr.html#ga396ac8bcc2959dcedad01f91bab8145e">avresample_convert</a>(avr, &amp;output, out_linesize, out_samples,</div>
<div class="line">                                     input, in_linesize, in_samples);</div>
<div class="line">    handle_output(output, out_linesize, out_samples);</div>
<div class="line">    <a class="code" href="group__lavu__mem.html#ga0cc84043ea2167ad005c86e11d0bcdba">av_freep</a>(&amp;output);</div>
<div class="line"> }</div>
</div><!-- fragment --><p>When the conversion is finished and the FIFOs are flushed if required, the conversion context and everything associated with it must be freed with <a class="el" href="group__lavr.html#ga1d0782fe9a331b823c6d0dda5dbc63a5">avresample_free()</a>. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaaaa652e3ad8554a0dca126e8571735dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavr.html#gaaaa652e3ad8554a0dca126e8571735dd">AVMixCoeffType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mixing Coefficient Types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggaaaa652e3ad8554a0dca126e8571735ddaf459c8599c850abd5d0308cd8609af68"></a>AV_MIX_COEFF_TYPE_Q15</em>&#160;</td><td class="fielddoc">
<p>16-bit 8.8 fixed-point </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaaa652e3ad8554a0dca126e8571735dda5d6c3ee92cc045714ac2ec4c83588841"></a>AV_MIX_COEFF_TYPE_FLT</em>&#160;</td><td class="fielddoc">
<p>32-bit 17.15 fixed-point </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaaaa652e3ad8554a0dca126e8571735dda2672ba31292b1fb0a861b035466964a9"></a>AV_MIX_COEFF_TYPE_NB</em>&#160;</td><td class="fielddoc">
<p>floating-point </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga302491313b02acca1a822249caa8cb10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavr.html#ga302491313b02acca1a822249caa8cb10">AVResampleDitherMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga302491313b02acca1a822249caa8cb10a4f892b254f02b3ebf775169f786e966b"></a>AV_RESAMPLE_DITHER_NONE</em>&#160;</td><td class="fielddoc">
<p>Do not use dithering </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga302491313b02acca1a822249caa8cb10a6e6841e6042d8059db5fdebe67d783ad"></a>AV_RESAMPLE_DITHER_RECTANGULAR</em>&#160;</td><td class="fielddoc">
<p>Rectangular Dither </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga302491313b02acca1a822249caa8cb10a4d9b50692d2a3cdf6c3cfeb7f14ccfc6"></a>AV_RESAMPLE_DITHER_TRIANGULAR</em>&#160;</td><td class="fielddoc">
<p>Triangular Dither </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga302491313b02acca1a822249caa8cb10a261d5a5101aeff5e7ff5813787481bd6"></a>AV_RESAMPLE_DITHER_TRIANGULAR_HP</em>&#160;</td><td class="fielddoc">
<p>Triangular Dither with High Pass </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga302491313b02acca1a822249caa8cb10aa1abacc1c6e8c448959bc49316b8f566"></a>AV_RESAMPLE_DITHER_TRIANGULAR_NS</em>&#160;</td><td class="fielddoc">
<p>Triangular Dither with Noise Shaping </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga302491313b02acca1a822249caa8cb10ac9e29d7f4af2590ba9a59429d88d57c0"></a>AV_RESAMPLE_DITHER_NB</em>&#160;</td><td class="fielddoc">
<p>Number of dither types. Not part of ABI. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga3813087032c02f1e84f0ca2962b09400"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavr.html#ga3813087032c02f1e84f0ca2962b09400">AVResampleFilterType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resampling Filter Types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga3813087032c02f1e84f0ca2962b09400ac8d3b66c4c4bd02418ce0b882fb7d4fa"></a>AV_RESAMPLE_FILTER_TYPE_CUBIC</em>&#160;</td><td class="fielddoc">
<p>Cubic </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3813087032c02f1e84f0ca2962b09400ace0cbc5bda3d6fa26b054b2fa7702886"></a>AV_RESAMPLE_FILTER_TYPE_BLACKMAN_NUTTALL</em>&#160;</td><td class="fielddoc">
<p>Blackman Nuttall Windowed Sinc </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3813087032c02f1e84f0ca2962b09400af552d08855b8a5f4b46f6328633c8f1f"></a>AV_RESAMPLE_FILTER_TYPE_KAISER</em>&#160;</td><td class="fielddoc">
<p>Kaiser Windowed Sinc </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5b1bcb7a35446a07ce330a0ca2b38b72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVAudioResampleContext* avresample_alloc_context </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate AVAudioResampleContext and set options.</p>
<dl class="section return"><dt>Returns</dt><dd>allocated audio resample context, or NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ed549e1e347ab11bb81883b9ce6bca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avresample_available </td>
          <td>(</td>
          <td class="paramtype">AVAudioResampleContext *&#160;</td>
          <td class="paramname"><em>avr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of available samples in the output FIFO.</p>
<p>During conversion, if the user does not specify an output buffer or specifies an output buffer that is smaller than what is needed, remaining samples that are not written to the output are stored to an internal FIFO buffer. The samples in the FIFO can be read with <a class="el" href="group__lavr.html#gae115c3f6edea41ae634583737bc554f9">avresample_read()</a> or <a class="el" href="group__lavr.html#ga396ac8bcc2959dcedad01f91bab8145e">avresample_convert()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__lavr.html#gae115c3f6edea41ae634583737bc554f9">avresample_read()</a> </dd>
<dd>
<a class="el" href="group__lavr.html#ga396ac8bcc2959dcedad01f91bab8145e">avresample_convert()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avr</td><td>audio resample context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of samples available for reading </dd></dl>

</div>
</div>
<a class="anchor" id="ga496a46260f4a5f5854ecc21f0f0011c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avresample_build_matrix </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>in_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>out_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>center_mix_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>surround_mix_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lfe_mix_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>normalize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum AVMatrixEncoding&#160;</td>
          <td class="paramname"><em>matrix_encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a channel mixing matrix.</p>
<p>This function is the one used internally by libavresample for building the default mixing matrix. It is made public just as a utility function for building custom matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">in_layout</td><td>input channel layout </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_layout</td><td>output channel layout </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">center_mix_level</td><td>mix level for the center channel </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">surround_mix_level</td><td>mix level for the surround channel(s) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lfe_mix_level</td><td>mix level for the low-frequency effects channel </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">normalize</td><td>if 1, coefficients will be normalized to prevent overflow. if 0, coefficients will not be normalized. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>mixing coefficients; matrix[i + stride * o] is the weight of input channel i in output channel o. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">stride</td><td>distance between adjacent input channels in the matrix array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">matrix_encoding</td><td>matrixed stereo downmix mode (e.g. dplii) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative AVERROR code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga30751a8c6923418a090281669362bf79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avresample_close </td>
          <td>(</td>
          <td class="paramtype">AVAudioResampleContext *&#160;</td>
          <td class="paramname"><em>avr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close AVAudioResampleContext.</p>
<p>This closes the context, but it does not change the parameters. The context can be reopened with <a class="el" href="group__lavr.html#gafc59c68689be880494ff24d10fd85143">avresample_open()</a>. It does, however, clear the output FIFO and any remaining leftover samples in the resampling delay buffer. If there was a custom matrix being used, that is also cleared.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__lavr.html#ga396ac8bcc2959dcedad01f91bab8145e">avresample_convert()</a> </dd>
<dd>
<a class="el" href="group__lavr.html#ga3311c71aa573523c04882809143a9107">avresample_set_matrix()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avr</td><td>audio resample context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga59d94ba578f9d7a90fd5d82ee6f361b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* avresample_configuration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the libavresample build-time configuration. </p>
<dl class="section return"><dt>Returns</dt><dd>configure string </dd></dl>

</div>
</div>
<a class="anchor" id="ga396ac8bcc2959dcedad01f91bab8145e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avresample_convert </td>
          <td>(</td>
          <td class="paramtype">AVAudioResampleContext *&#160;</td>
          <td class="paramname"><em>avr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>out_plane_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>out_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_plane_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert input samples and write them to the output FIFO.</p>
<p>The upper bound on the number of output samples is given by <a class="el" href="group__lavr.html#ga1ed549e1e347ab11bb81883b9ce6bca2">avresample_available()</a> + (<a class="el" href="group__lavr.html#ga66240ec48b20c7a688ea0cd5fae6db15">avresample_get_delay()</a> + number of input samples) * output sample rate / input sample rate.</p>
<p>The output data can be NULL or have fewer allocated samples than required. In this case, any remaining samples not written to the output will be added to an internal FIFO buffer, to be returned at the next call to this function or to <a class="el" href="group__lavr.html#gae115c3f6edea41ae634583737bc554f9">avresample_read()</a>.</p>
<p>If converting sample rate, there may be data remaining in the internal resampling delay buffer. <a class="el" href="group__lavr.html#ga66240ec48b20c7a688ea0cd5fae6db15">avresample_get_delay()</a> tells the number of remaining samples. To get this data as output, call <a class="el" href="group__lavr.html#ga396ac8bcc2959dcedad01f91bab8145e">avresample_convert()</a> with NULL input.</p>
<p>At the end of the conversion process, there may be data remaining in the internal FIFO buffer. <a class="el" href="group__lavr.html#ga1ed549e1e347ab11bb81883b9ce6bca2">avresample_available()</a> tells the number of remaining samples. To get this data as output, either call <a class="el" href="group__lavr.html#ga396ac8bcc2959dcedad01f91bab8145e">avresample_convert()</a> with NULL input or call <a class="el" href="group__lavr.html#gae115c3f6edea41ae634583737bc554f9">avresample_read()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__lavr.html#ga1ed549e1e347ab11bb81883b9ce6bca2">avresample_available()</a> </dd>
<dd>
<a class="el" href="group__lavr.html#gae115c3f6edea41ae634583737bc554f9">avresample_read()</a> </dd>
<dd>
<a class="el" href="group__lavr.html#ga66240ec48b20c7a688ea0cd5fae6db15">avresample_get_delay()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avr</td><td>audio resample context </td></tr>
    <tr><td class="paramname">output</td><td>output data pointers </td></tr>
    <tr><td class="paramname">out_plane_size</td><td>output plane size, in bytes. This can be 0 if unknown, but that will lead to optimized functions not being used directly on the output, which could slow down some conversions. </td></tr>
    <tr><td class="paramname">out_samples</td><td>maximum number of samples that the output buffer can hold </td></tr>
    <tr><td class="paramname">input</td><td>input data pointers </td></tr>
    <tr><td class="paramname">in_plane_size</td><td>input plane size, in bytes This can be 0 if unknown, but that will lead to optimized functions not being used directly on the input, which could slow down some conversions. </td></tr>
    <tr><td class="paramname">in_samples</td><td>number of input samples to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of samples written to the output buffer, not including converted samples added to the internal output FIFO </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d0782fe9a331b823c6d0dda5dbc63a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avresample_free </td>
          <td>(</td>
          <td class="paramtype">AVAudioResampleContext **&#160;</td>
          <td class="paramname"><em>avr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free AVAudioResampleContext and associated <a class="el" href="struct_a_v_option.html">AVOption</a> values.</p>
<p>This also calls <a class="el" href="group__lavr.html#ga30751a8c6923418a090281669362bf79">avresample_close()</a> before freeing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avr</td><td>audio resample context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga40d8eeb3181386e30e5b02289e469a73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_a_v_class.html">AVClass</a>* avresample_get_class </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the <a class="el" href="struct_a_v_class.html">AVClass</a> for AVAudioResampleContext.</p>
<p>Can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options without allocating a context.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__avoptions.html#gae31ae7fb20113b00108d0ecf53f25664">av_opt_find()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_a_v_class.html">AVClass</a> for AVAudioResampleContext </dd></dl>

</div>
</div>
<a class="anchor" id="ga66240ec48b20c7a688ea0cd5fae6db15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avresample_get_delay </td>
          <td>(</td>
          <td class="paramtype">AVAudioResampleContext *&#160;</td>
          <td class="paramname"><em>avr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of samples currently in the resampling delay buffer.</p>
<p>When resampling, there may be a delay between the input and output. Any unconverted samples in each call are stored internally in a delay buffer. This function allows the user to determine the current number of samples in the delay buffer, which can be useful for synchronization.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__lavr.html#ga396ac8bcc2959dcedad01f91bab8145e">avresample_convert()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avr</td><td>audio resample context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of samples currently in the resampling delay buffer </dd></dl>

</div>
</div>
<a class="anchor" id="ga74d920b2dd1af265d7186a33f60e08e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avresample_get_matrix </td>
          <td>(</td>
          <td class="paramtype">AVAudioResampleContext *&#160;</td>
          <td class="paramname"><em>avr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current channel mixing matrix.</p>
<p>If no custom matrix has been previously set or the AVAudioResampleContext is not open, an error is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avr</td><td>audio resample context </td></tr>
    <tr><td class="paramname">matrix</td><td>mixing coefficients; matrix[i + stride * o] is the weight of input channel i in output channel o. </td></tr>
    <tr><td class="paramname">stride</td><td>distance between adjacent input channels in the matrix array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative AVERROR code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e3794756514c6ccf42580c2a840d16c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* avresample_license </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the libavresample license. </p>

</div>
</div>
<a class="anchor" id="gafc59c68689be880494ff24d10fd85143"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avresample_open </td>
          <td>(</td>
          <td class="paramtype">AVAudioResampleContext *&#160;</td>
          <td class="paramname"><em>avr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize AVAudioResampleContext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avr</td><td>audio resample context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative AVERROR code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gae115c3f6edea41ae634583737bc554f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avresample_read </td>
          <td>(</td>
          <td class="paramtype">AVAudioResampleContext *&#160;</td>
          <td class="paramname"><em>avr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read samples from the output FIFO.</p>
<p>During conversion, if the user does not specify an output buffer or specifies an output buffer that is smaller than what is needed, remaining samples that are not written to the output are stored to an internal FIFO buffer. This function can be used to read samples from that internal FIFO.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__lavr.html#ga1ed549e1e347ab11bb81883b9ce6bca2">avresample_available()</a> </dd>
<dd>
<a class="el" href="group__lavr.html#ga396ac8bcc2959dcedad01f91bab8145e">avresample_convert()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avr</td><td>audio resample context </td></tr>
    <tr><td class="paramname">output</td><td>output data pointers. May be NULL, in which case nb_samples of data is discarded from output FIFO. </td></tr>
    <tr><td class="paramname">nb_samples</td><td>number of samples to read from the FIFO </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of samples written to output </dd></dl>

</div>
</div>
<a class="anchor" id="gafc3b3ffa44345e07babdd69267527cfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avresample_set_channel_mapping </td>
          <td>(</td>
          <td class="paramtype">AVAudioResampleContext *&#160;</td>
          <td class="paramname"><em>avr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>channel_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a customized input channel mapping.</p>
<p>This function can only be called when the allocated context is not open. Also, the input channel layout must have already been set.</p>
<p>Calling <a class="el" href="group__lavr.html#ga30751a8c6923418a090281669362bf79">avresample_close()</a> on the context will clear the channel mapping.</p>
<p>The map for each input channel specifies the channel index in the source to use for that particular channel, or -1 to mute the channel. Source channels can be duplicated by using the same index for multiple input channels.</p>
<p>Examples:</p>
<p>Reordering 5.1 AAC order (C,L,R,Ls,Rs,LFE) to Libav order (L,R,C,LFE,Ls,Rs): { 1, 2, 0, 5, 3, 4 }</p>
<p>Muting the 3rd channel in 4-channel input: { 0, 1, -1, 3 }</p>
<p>Duplicating the left channel of stereo input: { 0, 0 }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avr</td><td>audio resample context </td></tr>
    <tr><td class="paramname">channel_map</td><td>customized input channel mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative AVERROR code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c7722a7b56ed3c4a44174611316d6ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avresample_set_compensation </td>
          <td>(</td>
          <td class="paramtype">AVAudioResampleContext *&#160;</td>
          <td class="paramname"><em>avr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sample_delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compensation_distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set compensation for resampling.</p>
<p>This can be called anytime after <a class="el" href="group__lavr.html#gafc59c68689be880494ff24d10fd85143">avresample_open()</a>. If resampling is not automatically enabled because of a sample rate conversion, the "force_resampling" option must have been set to 1 when opening the context in order to use resampling compensation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avr</td><td>audio resample context </td></tr>
    <tr><td class="paramname">sample_delta</td><td>compensation delta, in samples </td></tr>
    <tr><td class="paramname">compensation_distance</td><td>compensation distance, in samples </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative AVERROR code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga3311c71aa573523c04882809143a9107"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avresample_set_matrix </td>
          <td>(</td>
          <td class="paramtype">AVAudioResampleContext *&#160;</td>
          <td class="paramname"><em>avr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set channel mixing matrix.</p>
<p>Allows for setting a custom mixing matrix, overriding the default matrix generated internally during <a class="el" href="group__lavr.html#gafc59c68689be880494ff24d10fd85143">avresample_open()</a>. This function can be called anytime on an allocated context, either before or after calling <a class="el" href="group__lavr.html#gafc59c68689be880494ff24d10fd85143">avresample_open()</a>, as long as the channel layouts have been set. <a class="el" href="group__lavr.html#ga396ac8bcc2959dcedad01f91bab8145e">avresample_convert()</a> always uses the current matrix. Calling <a class="el" href="group__lavr.html#ga30751a8c6923418a090281669362bf79">avresample_close()</a> on the context will clear the current matrix.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__lavr.html#ga30751a8c6923418a090281669362bf79">avresample_close()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avr</td><td>audio resample context </td></tr>
    <tr><td class="paramname">matrix</td><td>mixing coefficients; matrix[i + stride * o] is the weight of input channel i in output channel o. </td></tr>
    <tr><td class="paramname">stride</td><td>distance between adjacent input channels in the matrix array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative AVERROR code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gaedabbb0590c33b7b9ce1ce213629dd3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned avresample_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the LIBAVRESAMPLE_VERSION_INT constant. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Jan 11 2014 18:32:16 for ofxLibav by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
