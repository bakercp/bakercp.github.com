<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ofxLibav: Utility functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ofxLibav
   </div>
   <div id="projectbrief">A small wrapper for libav.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__lavc__misc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utility functions<div class="ingroups"><a class="el" href="group__libavc.html">Encoding/Decoding Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__lavc__misc__pixfmt"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc__pixfmt.html">Pixel formats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__lavc__fft"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__fft.html">FFT functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_bit_stream_filter.html">AVBitStreamFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2ab47771ac6385c834d0fb0bac71b609"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ab47771ac6385c834d0fb0bac71b609"></a>
typedef struct <br class="typebreak"/>
<a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AVBitStreamFilterContext</b></td></tr>
<tr class="separator:ga2ab47771ac6385c834d0fb0bac71b609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea3871dd20e820423b0abad16a7d0ac4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaea3871dd20e820423b0abad16a7d0ac4"></a>
typedef struct <a class="el" href="struct_a_v_bit_stream_filter.html">AVBitStreamFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AVBitStreamFilter</b></td></tr>
<tr class="separator:gaea3871dd20e820423b0abad16a7d0ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7a013315e444069ec9630ddf3edce3f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga7a013315e444069ec9630ddf3edce3f8">AVLockOp</a> { <a class="el" href="group__lavc__misc.html#gga7a013315e444069ec9630ddf3edce3f8a486a4a2d7a97554c2e073536c038465d">AV_LOCK_CREATE</a>, 
<a class="el" href="group__lavc__misc.html#gga7a013315e444069ec9630ddf3edce3f8af684bbd8575f2686f42346f5e43be673">AV_LOCK_OBTAIN</a>, 
<a class="el" href="group__lavc__misc.html#gga7a013315e444069ec9630ddf3edce3f8a7c470cd815cdef3b16a977e9a8c89c69">AV_LOCK_RELEASE</a>, 
<a class="el" href="group__lavc__misc.html#gga7a013315e444069ec9630ddf3edce3f8aee9ae55e2efe16565998e473c2a18935">AV_LOCK_DESTROY</a>
 }</td></tr>
<tr class="separator:ga7a013315e444069ec9630ddf3edce3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga041ef6fb5785490db0bf85e50883efb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga041ef6fb5785490db0bf85e50883efb8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>avcodec_set_dimensions</b> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *s, int width, int height)</td></tr>
<tr class="separator:ga041ef6fb5785490db0bf85e50883efb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f9e278e427564ee2e8b0ad875dbe5df"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga1f9e278e427564ee2e8b0ad875dbe5df">av_get_codec_tag_string</a> (char *buf, size_t buf_size, unsigned int codec_tag)</td></tr>
<tr class="separator:ga1f9e278e427564ee2e8b0ad875dbe5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4056568b5ab73d2e55800d9a5caa66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6d4056568b5ab73d2e55800d9a5caa66"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>avcodec_string</b> (char *buf, int buf_size, <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *enc, int encode)</td></tr>
<tr class="separator:ga6d4056568b5ab73d2e55800d9a5caa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc4a8003d0818a235bde2d8fbe81e11"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga0dc4a8003d0818a235bde2d8fbe81e11">av_get_profile_name</a> (const <a class="el" href="struct_a_v_codec.html">AVCodec</a> *codec, int profile)</td></tr>
<tr class="separator:ga0dc4a8003d0818a235bde2d8fbe81e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ccd730ba6e891b6c61da68ab138c63f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9ccd730ba6e891b6c61da68ab138c63f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>avcodec_default_execute</b> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c, int(*func)(<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c2, void *arg2), void *arg, int *ret, int count, int size)</td></tr>
<tr class="separator:ga9ccd730ba6e891b6c61da68ab138c63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga365b89d7f5b6dc9f930f07ec4078a611"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga365b89d7f5b6dc9f930f07ec4078a611"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>avcodec_default_execute2</b> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c, int(*func)(<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c2, void *arg2, int, int), void *arg, int *ret, int count)</td></tr>
<tr class="separator:ga365b89d7f5b6dc9f930f07ec4078a611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b44aad56fa22a78fb8916eb8cc0516"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga66b44aad56fa22a78fb8916eb8cc0516">avcodec_fill_audio_frame</a> (<a class="el" href="struct_a_v_frame.html">AVFrame</a> *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)</td></tr>
<tr class="separator:ga66b44aad56fa22a78fb8916eb8cc0516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60b0e076f822abcb2700eb601d352a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#gaf60b0e076f822abcb2700eb601d352a6">avcodec_flush_buffers</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *avctx)</td></tr>
<tr class="separator:gaf60b0e076f822abcb2700eb601d352a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0717e7440fdb123f708082f66cd9b41d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga0717e7440fdb123f708082f66cd9b41d">av_get_bits_per_sample</a> (enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> codec_id)</td></tr>
<tr class="separator:ga0717e7440fdb123f708082f66cd9b41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadddbcd146ffaf53016bac730c631f7b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#gadddbcd146ffaf53016bac730c631f7b3">av_get_exact_bits_per_sample</a> (enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> codec_id)</td></tr>
<tr class="separator:gadddbcd146ffaf53016bac730c631f7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3266a8c3df0790c62259f91afcde45a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga3266a8c3df0790c62259f91afcde45a9">av_get_audio_frame_duration</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *avctx, int frame_bytes)</td></tr>
<tr class="separator:ga3266a8c3df0790c62259f91afcde45a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga520e0d7584b92d70e51ff0fcc3551764"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga520e0d7584b92d70e51ff0fcc3551764"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>av_register_bitstream_filter</b> (<a class="el" href="struct_a_v_bit_stream_filter.html">AVBitStreamFilter</a> *bsf)</td></tr>
<tr class="separator:ga520e0d7584b92d70e51ff0fcc3551764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f87a57cd7c08c1d9b9bfe1a4bd611f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f87a57cd7c08c1d9b9bfe1a4bd611f3"></a>
<a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>av_bitstream_filter_init</b> (const char *name)</td></tr>
<tr class="separator:ga4f87a57cd7c08c1d9b9bfe1a4bd611f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab3bf4e396f0bbc5151df6af765543d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ab3bf4e396f0bbc5151df6af765543d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>av_bitstream_filter_filter</b> (<a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a> *bsfc, <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *avctx, const char *args, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int keyframe)</td></tr>
<tr class="separator:ga1ab3bf4e396f0bbc5151df6af765543d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabee15852c201976249e89964161a44b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabee15852c201976249e89964161a44b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>av_bitstream_filter_close</b> (<a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a> *bsf)</td></tr>
<tr class="separator:gabee15852c201976249e89964161a44b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa84824e00f3d1266b8391807511836d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa84824e00f3d1266b8391807511836d4"></a>
<a class="el" href="struct_a_v_bit_stream_filter.html">AVBitStreamFilter</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>av_bitstream_filter_next</b> (<a class="el" href="struct_a_v_bit_stream_filter.html">AVBitStreamFilter</a> *f)</td></tr>
<tr class="separator:gaa84824e00f3d1266b8391807511836d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga869fd8884d8d29a7a4910d879926d94a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga869fd8884d8d29a7a4910d879926d94a">av_fast_realloc</a> (void *ptr, unsigned int *size, size_t min_size)</td></tr>
<tr class="separator:ga869fd8884d8d29a7a4910d879926d94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29d0252b981f157e713a68ffca52f003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga29d0252b981f157e713a68ffca52f003">av_fast_malloc</a> (void *ptr, unsigned int *size, size_t min_size)</td></tr>
<tr class="separator:ga29d0252b981f157e713a68ffca52f003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04a23a2336412504052d5c4e0c7716ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga04a23a2336412504052d5c4e0c7716ee">av_fast_padded_malloc</a> (void *ptr, unsigned int *size, size_t min_size)</td></tr>
<tr class="separator:ga04a23a2336412504052d5c4e0c7716ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga144411ccbce77847ee9ce10d7fe5361c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga144411ccbce77847ee9ce10d7fe5361c">av_xiphlacing</a> (unsigned char *s, unsigned int v)</td></tr>
<tr class="separator:ga144411ccbce77847ee9ce10d7fe5361c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33778497768bad3ccdf81bd45511a1ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga33778497768bad3ccdf81bd45511a1ae">av_register_hwaccel</a> (<a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a> *hwaccel)</td></tr>
<tr class="separator:ga33778497768bad3ccdf81bd45511a1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga943e869effb55cc86c923ef0db23de1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga943e869effb55cc86c923ef0db23de1b">av_hwaccel_next</a> (<a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a> *hwaccel)</td></tr>
<tr class="separator:ga943e869effb55cc86c923ef0db23de1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae120ec60cdf49cf0f793eff3ec731bcc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#gae120ec60cdf49cf0f793eff3ec731bcc">av_lockmgr_register</a> (int(*cb)(void **mutex, enum <a class="el" href="group__lavc__misc.html#ga7a013315e444069ec9630ddf3edce3f8">AVLockOp</a> op))</td></tr>
<tr class="separator:gae120ec60cdf49cf0f793eff3ec731bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9680ab906f1206deafc521ed54927375"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavu__misc.html#ga9a84bba4713dfced21a1a56163be1f48">AVMediaType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga9680ab906f1206deafc521ed54927375">avcodec_get_type</a> (enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> codec_id)</td></tr>
<tr class="separator:ga9680ab906f1206deafc521ed54927375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga906dda732e79eac12067c6d7ea19b630"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga906dda732e79eac12067c6d7ea19b630">avcodec_is_open</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *s)</td></tr>
<tr class="separator:ga906dda732e79eac12067c6d7ea19b630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b665824e4d9144f8d4f6c01e3e85aa3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga2b665824e4d9144f8d4f6c01e3e85aa3">av_codec_is_encoder</a> (const <a class="el" href="struct_a_v_codec.html">AVCodec</a> *codec)</td></tr>
<tr class="separator:ga2b665824e4d9144f8d4f6c01e3e85aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc18eef1afca3610644a52565cf8a31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga6dc18eef1afca3610644a52565cf8a31">av_codec_is_decoder</a> (const <a class="el" href="struct_a_v_codec.html">AVCodec</a> *codec)</td></tr>
<tr class="separator:ga6dc18eef1afca3610644a52565cf8a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac09f8ddc2d4b36c5a85c6befba0d0888"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_a_v_codec_descriptor.html">AVCodecDescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#gac09f8ddc2d4b36c5a85c6befba0d0888">avcodec_descriptor_get</a> (enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> id)</td></tr>
<tr class="separator:gac09f8ddc2d4b36c5a85c6befba0d0888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga909ef5261eafb1be1871f718353632bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_a_v_codec_descriptor.html">AVCodecDescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga909ef5261eafb1be1871f718353632bd">avcodec_descriptor_next</a> (const <a class="el" href="struct_a_v_codec_descriptor.html">AVCodecDescriptor</a> *prev)</td></tr>
<tr class="separator:ga909ef5261eafb1be1871f718353632bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga199f854b030f24bd31d251f9d36f1392"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_a_v_codec_descriptor.html">AVCodecDescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga199f854b030f24bd31d251f9d36f1392">avcodec_descriptor_get_by_name</a> (const char *name)</td></tr>
<tr class="separator:ga199f854b030f24bd31d251f9d36f1392"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Miscellaneous utility functions related to both encoding and decoding (or neither). </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga7a013315e444069ec9630ddf3edce3f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__misc.html#ga7a013315e444069ec9630ddf3edce3f8">AVLockOp</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock operation used by lockmgr </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga7a013315e444069ec9630ddf3edce3f8a486a4a2d7a97554c2e073536c038465d"></a>AV_LOCK_CREATE</em>&#160;</td><td class="fielddoc">
<p>Create a mutex. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7a013315e444069ec9630ddf3edce3f8af684bbd8575f2686f42346f5e43be673"></a>AV_LOCK_OBTAIN</em>&#160;</td><td class="fielddoc">
<p>Lock the mutex. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7a013315e444069ec9630ddf3edce3f8a7c470cd815cdef3b16a977e9a8c89c69"></a>AV_LOCK_RELEASE</em>&#160;</td><td class="fielddoc">
<p>Unlock the mutex. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga7a013315e444069ec9630ddf3edce3f8aee9ae55e2efe16565998e473c2a18935"></a>AV_LOCK_DESTROY</em>&#160;</td><td class="fielddoc">
<p>Free mutex resources. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6dc18eef1afca3610644a52565cf8a31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_codec_is_decoder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_v_codec.html">AVCodec</a> *&#160;</td>
          <td class="paramname"><em>codec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-zero number if codec is a decoder, zero otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b665824e4d9144f8d4f6c01e3e85aa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_codec_is_encoder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_v_codec.html">AVCodec</a> *&#160;</td>
          <td class="paramname"><em>codec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-zero number if codec is an encoder, zero otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga29d0252b981f157e713a68ffca52f003"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_fast_malloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a buffer, reusing the given one if large enough.</p>
<p>Contrary to av_fast_realloc the current buffer contents might not be preserved and on error the old buffer is freed, thus no special handling to avoid memleaks is necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to pointer to already allocated buffer, overwritten with pointer to new buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of the buffer *ptr points to </td></tr>
    <tr><td class="paramname">min_size</td><td>minimum size of *ptr buffer after returning, *ptr will be NULL and *size 0 if an error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga04a23a2336412504052d5c4e0c7716ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_fast_padded_malloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a buffer with padding, reusing the given one if large enough.</p>
<p>Same behaviour av_fast_malloc but the buffer has additional FF_INPUT_PADDING_SIZE at the end which will always memset to 0. </p>

</div>
</div>
<a class="anchor" id="ga869fd8884d8d29a7a4910d879926d94a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* av_fast_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reallocate the given block if it is not large enough, otherwise do nothing.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__lavu__mem.html#ga74bb2298daa9cd0b5f1d0b2c1c3e26bb">av_realloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3266a8c3df0790c62259f91afcde45a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_get_audio_frame_duration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return audio frame duration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avctx</td><td>codec context </td></tr>
    <tr><td class="paramname">frame_bytes</td><td>size of the frame, or 0 if unknown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>frame duration, in samples, if known. 0 if not able to determine. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0717e7440fdb123f708082f66cd9b41d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_get_bits_per_sample </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td>
          <td class="paramname"><em>codec_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return codec bits per sample.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>the codec </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bits per sample or zero if unknown for the given codec. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f9e278e427564ee2e8b0ad875dbe5df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t av_get_codec_tag_string </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>codec_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put a string representing the codec tag codec_tag in buf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_size</td><td>size in bytes of buf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string that would have been generated if enough space had been available, excluding the trailing null </dd></dl>

</div>
</div>
<a class="anchor" id="gadddbcd146ffaf53016bac730c631f7b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_get_exact_bits_per_sample </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td>
          <td class="paramname"><em>codec_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return codec bits per sample. Only return non-zero if the bits per sample is exactly correct, not an approximation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>the codec </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bits per sample or zero if unknown for the given codec. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0dc4a8003d0818a235bde2d8fbe81e11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* av_get_profile_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_v_codec.html">AVCodec</a> *&#160;</td>
          <td class="paramname"><em>codec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a name for the specified profile, if available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codec</td><td>the codec that is searched for the given profile </td></tr>
    <tr><td class="paramname">profile</td><td>the profile value for which a name is requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A name for the profile if found, NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga943e869effb55cc86c923ef0db23de1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a>* av_hwaccel_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a> *&#160;</td>
          <td class="paramname"><em>hwaccel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If hwaccel is NULL, returns the first registered hardware accelerator, if hwaccel is non-NULL, returns the next registered hardware accelerator after hwaccel, or NULL if hwaccel is the last one. </p>

</div>
</div>
<a class="anchor" id="gae120ec60cdf49cf0f793eff3ec731bcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_lockmgr_register </td>
          <td>(</td>
          <td class="paramtype">int(*)(void **mutex, enum <a class="el" href="group__lavc__misc.html#ga7a013315e444069ec9630ddf3edce3f8">AVLockOp</a> op)&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a user provided lock manager supporting the operations specified by AVLockOp. mutex points to a (void *) where the lockmgr should store/get a pointer to a user allocated mutex. It's NULL upon AV_LOCK_CREATE and != NULL for all other ops.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>User defined callback. Note: Libav may invoke calls to this callback during the call to <a class="el" href="group__lavc__misc.html#gae120ec60cdf49cf0f793eff3ec731bcc">av_lockmgr_register()</a>. Thus, the application must be prepared to handle that. If cb is set to NULL the lockmgr will be unregistered. Also note that during unregistration the previously registered lockmgr callback may also be invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga33778497768bad3ccdf81bd45511a1ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_register_hwaccel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a> *&#160;</td>
          <td class="paramname"><em>hwaccel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register the hardware accelerator hwaccel. </p>

</div>
</div>
<a class="anchor" id="ga144411ccbce77847ee9ce10d7fe5361c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int av_xiphlacing </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encode extradata length to a buffer. Used by xiph codecs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>buffer to write to; must be at least (v/255+1) bytes long </td></tr>
    <tr><td class="paramname">v</td><td>size of extradata in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="gac09f8ddc2d4b36c5a85c6befba0d0888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_a_v_codec_descriptor.html">AVCodecDescriptor</a>* avcodec_descriptor_get </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>descriptor for given codec ID or NULL if no descriptor exists. </dd></dl>

</div>
</div>
<a class="anchor" id="ga199f854b030f24bd31d251f9d36f1392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_a_v_codec_descriptor.html">AVCodecDescriptor</a>* avcodec_descriptor_get_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>codec descriptor with the given name or NULL if no such descriptor exists. </dd></dl>

</div>
</div>
<a class="anchor" id="ga909ef5261eafb1be1871f718353632bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_a_v_codec_descriptor.html">AVCodecDescriptor</a>* avcodec_descriptor_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_v_codec_descriptor.html">AVCodecDescriptor</a> *&#160;</td>
          <td class="paramname"><em>prev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over all codec descriptors known to libavcodec.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>previous descriptor. NULL to get the first descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next descriptor or NULL after the last descriptor </dd></dl>

</div>
</div>
<a class="anchor" id="ga66b44aad56fa22a78fb8916eb8cc0516"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avcodec_fill_audio_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_frame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum AVSampleFormat&#160;</td>
          <td class="paramname"><em>sample_fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill audio frame data and linesize. <a class="el" href="struct_a_v_frame.html">AVFrame</a> extended_data channel pointers are allocated if necessary for planar audio.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>the <a class="el" href="struct_a_v_frame.html">AVFrame</a> frame-&gt;nb_samples must be set prior to calling the function. This function fills in frame-&gt;data, frame-&gt;extended_data, frame-&gt;linesize[0]. </td></tr>
    <tr><td class="paramname">nb_channels</td><td>channel count </td></tr>
    <tr><td class="paramname">sample_fmt</td><td>sample format </td></tr>
    <tr><td class="paramname">buf</td><td>buffer to use for frame data </td></tr>
    <tr><td class="paramname">buf_size</td><td>size of buffer </td></tr>
    <tr><td class="paramname">align</td><td>plane size sample alignment (0 = default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gaf60b0e076f822abcb2700eb601d352a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avcodec_flush_buffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush buffers, should be called when seeking or when switching to a different stream. </p>

</div>
</div>
<a class="anchor" id="ga9680ab906f1206deafc521ed54927375"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavu__misc.html#ga9a84bba4713dfced21a1a56163be1f48">AVMediaType</a> avcodec_get_type </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td>
          <td class="paramname"><em>codec_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the type of the given codec. </p>

</div>
</div>
<a class="anchor" id="ga906dda732e79eac12067c6d7ea19b630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avcodec_is_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a positive value if s is open (i.e. <a class="el" href="group__lavc__core.html#ga11f785a188d7d9df71621001465b0f1d">avcodec_open2()</a> was called on it with no corresponding <a class="el" href="group__lavc__core.html#gaf4daa92361efb3523ef5afeb0b54077f">avcodec_close()</a>), 0 otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Jan 11 2014 18:32:15 for ofxLibav by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
