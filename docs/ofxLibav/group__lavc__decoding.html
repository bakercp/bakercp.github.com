<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ofxLibav: Decoding</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ofxLibav
   </div>
   <div id="projectbrief">A small wrapper for libav.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__lavc__decoding.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Decoding<div class="ingroups"><a class="el" href="group__libavc.html">Encoding/Decoding Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__lavc__parsing"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__parsing.html">Frame parsing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9207dd7cb4ee4416f8fd1f7a63af34b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga9207dd7cb4ee4416f8fd1f7a63af34b7">FF_INPUT_BUFFER_PADDING_SIZE</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga9207dd7cb4ee4416f8fd1f7a63af34b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga352363bce7d3ed82c101b3bc001d1c16"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga352363bce7d3ed82c101b3bc001d1c16">AVDiscard</a> { <br/>
&#160;&#160;<a class="el" href="group__lavc__decoding.html#gga352363bce7d3ed82c101b3bc001d1c16a93d0436f7651b58debe3f995e2582dcd">AVDISCARD_NONE</a> =-16, 
<a class="el" href="group__lavc__decoding.html#gga352363bce7d3ed82c101b3bc001d1c16a81453d8c452e8ee794daf7fde1c80b5b">AVDISCARD_DEFAULT</a> = 0, 
<a class="el" href="group__lavc__decoding.html#gga352363bce7d3ed82c101b3bc001d1c16ac5a5a87ffcd6fb2362ac18449d29bde8">AVDISCARD_NONREF</a> = 8, 
<a class="el" href="group__lavc__decoding.html#gga352363bce7d3ed82c101b3bc001d1c16a776541ad00a4f13c3fdcd363988bffb3">AVDISCARD_BIDIR</a> = 16, 
<br/>
&#160;&#160;<a class="el" href="group__lavc__decoding.html#gga352363bce7d3ed82c101b3bc001d1c16a31c8164477d9f571f82003065d2ab6f1">AVDISCARD_NONKEY</a> = 32, 
<a class="el" href="group__lavc__decoding.html#gga352363bce7d3ed82c101b3bc001d1c16a07517e3890ba7e19a612945483dc066a">AVDISCARD_ALL</a> = 48
<br/>
 }</td></tr>
<tr class="separator:ga352363bce7d3ed82c101b3bc001d1c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga19a0ca553277f019dd5b0fec6e1f9dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_v_codec.html">AVCodec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga19a0ca553277f019dd5b0fec6e1f9dca">avcodec_find_decoder</a> (enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> id)</td></tr>
<tr class="separator:ga19a0ca553277f019dd5b0fec6e1f9dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga776f2359007e8457799503068419e791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_v_codec.html">AVCodec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga776f2359007e8457799503068419e791">avcodec_find_decoder_by_name</a> (const char *name)</td></tr>
<tr class="separator:ga776f2359007e8457799503068419e791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09dee227d3666720eff1f6913d11699d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga09dee227d3666720eff1f6913d11699d">avcodec_default_get_buffer2</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *s, <a class="el" href="struct_a_v_frame.html">AVFrame</a> *frame, int flags)</td></tr>
<tr class="separator:ga09dee227d3666720eff1f6913d11699d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46b124de35e7292bb681fa1ad55de695"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga46b124de35e7292bb681fa1ad55de695">avcodec_get_edge_width</a> (void)</td></tr>
<tr class="separator:ga46b124de35e7292bb681fa1ad55de695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48432a3760eec9fce0f0ef7b298859f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga48432a3760eec9fce0f0ef7b298859f1">avcodec_align_dimensions</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *s, int *width, int *height)</td></tr>
<tr class="separator:ga48432a3760eec9fce0f0ef7b298859f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e3269dc1b9e2c98e9371241722e7e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga34e3269dc1b9e2c98e9371241722e7e2">avcodec_align_dimensions2</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *s, int *width, int *height, int linesize_align[AV_NUM_DATA_POINTERS])</td></tr>
<tr class="separator:ga34e3269dc1b9e2c98e9371241722e7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8847025a0f6cf472fe6305532329d5d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga8847025a0f6cf472fe6305532329d5d6">avcodec_decode_audio4</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *avctx, <a class="el" href="struct_a_v_frame.html">AVFrame</a> *frame, int *got_frame_ptr, <a class="el" href="struct_a_v_packet.html">AVPacket</a> *avpkt)</td></tr>
<tr class="separator:ga8847025a0f6cf472fe6305532329d5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4048fd6893d4a001bdaa3d251f3c03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga3e4048fd6893d4a001bdaa3d251f3c03">avcodec_decode_video2</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *avctx, <a class="el" href="struct_a_v_frame.html">AVFrame</a> *picture, int *got_picture_ptr, <a class="el" href="struct_a_v_packet.html">AVPacket</a> *avpkt)</td></tr>
<tr class="separator:ga3e4048fd6893d4a001bdaa3d251f3c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47db1b7f294b9f92684401b9c66a7c4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga47db1b7f294b9f92684401b9c66a7c4b">avcodec_decode_subtitle2</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *avctx, <a class="el" href="struct_a_v_subtitle.html">AVSubtitle</a> *sub, int *got_sub_ptr, <a class="el" href="struct_a_v_packet.html">AVPacket</a> *avpkt)</td></tr>
<tr class="separator:ga47db1b7f294b9f92684401b9c66a7c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga9207dd7cb4ee4416f8fd1f7a63af34b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FF_INPUT_BUFFER_PADDING_SIZE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Required number of additionally allocated bytes at the end of the input bitstream for decoding. This is mainly needed because some optimized bitstream readers read 32 or 64 bit at once and could read over the end.<br/>
 Note: If the first 23 bits of the additional bytes are not 0, then damaged MPEG bitstreams could cause overread and segfault. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga352363bce7d3ed82c101b3bc001d1c16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__decoding.html#ga352363bce7d3ed82c101b3bc001d1c16">AVDiscard</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga352363bce7d3ed82c101b3bc001d1c16a93d0436f7651b58debe3f995e2582dcd"></a>AVDISCARD_NONE</em>&#160;</td><td class="fielddoc">
<p>discard nothing </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga352363bce7d3ed82c101b3bc001d1c16a81453d8c452e8ee794daf7fde1c80b5b"></a>AVDISCARD_DEFAULT</em>&#160;</td><td class="fielddoc">
<p>discard useless packets like 0 size packets in avi </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga352363bce7d3ed82c101b3bc001d1c16ac5a5a87ffcd6fb2362ac18449d29bde8"></a>AVDISCARD_NONREF</em>&#160;</td><td class="fielddoc">
<p>discard all non reference </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga352363bce7d3ed82c101b3bc001d1c16a776541ad00a4f13c3fdcd363988bffb3"></a>AVDISCARD_BIDIR</em>&#160;</td><td class="fielddoc">
<p>discard all bidirectional frames </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga352363bce7d3ed82c101b3bc001d1c16a31c8164477d9f571f82003065d2ab6f1"></a>AVDISCARD_NONKEY</em>&#160;</td><td class="fielddoc">
<p>discard all frames except keyframes </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga352363bce7d3ed82c101b3bc001d1c16a07517e3890ba7e19a612945483dc066a"></a>AVDISCARD_ALL</em>&#160;</td><td class="fielddoc">
<p>discard all </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga48432a3760eec9fce0f0ef7b298859f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avcodec_align_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you do not use any horizontal padding.</p>
<p>May only be used if a codec with CODEC_CAP_DR1 has been opened. If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased according to <a class="el" href="group__lavc__decoding.html#ga46b124de35e7292bb681fa1ad55de695">avcodec_get_edge_width()</a> before. </p>

</div>
</div>
<a class="anchor" id="ga34e3269dc1b9e2c98e9371241722e7e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avcodec_align_dimensions2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linesize_align</em>[AV_NUM_DATA_POINTERS]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you also ensure that all line sizes are a multiple of the respective linesize_align[i].</p>
<p>May only be used if a codec with CODEC_CAP_DR1 has been opened. If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased according to <a class="el" href="group__lavc__decoding.html#ga46b124de35e7292bb681fa1ad55de695">avcodec_get_edge_width()</a> before. </p>

</div>
</div>
<a class="anchor" id="ga8847025a0f6cf472fe6305532329d5d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avcodec_decode_audio4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_v_frame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>got_frame_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_v_packet.html">AVPacket</a> *&#160;</td>
          <td class="paramname"><em>avpkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decode the audio frame of size avpkt-&gt;size from avpkt-&gt;data into frame.</p>
<p>Some decoders may support multiple frames in a single <a class="el" href="struct_a_v_packet.html">AVPacket</a>. Such decoders would then just decode the first frame. In this case, avcodec_decode_audio4 has to be called again with an <a class="el" href="struct_a_v_packet.html">AVPacket</a> containing the remaining data in order to decode the second frame, etc... Even if no frames are returned, the packet needs to be fed to the decoder with remaining data until it is completely consumed or an error occurs.</p>
<dl class="section warning"><dt>Warning</dt><dd>The input buffer, avpkt-&gt;data must be FF_INPUT_BUFFER_PADDING_SIZE larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You might have to align the input buffer. The alignment requirements depend on the CPU and the decoder.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">avctx</td><td>the codec context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">frame</td><td>The <a class="el" href="struct_a_v_frame.html">AVFrame</a> in which to store decoded audio samples. The decoder will allocate a buffer for the decoded frame by calling the <a class="el" href="struct_a_v_codec_context.html#a7c93198032a3a728b13cb7d7e637d295">AVCodecContext.get_buffer2()</a> callback. When <a class="el" href="struct_a_v_codec_context.html#ab16d1e0c729a7b63d918d5ec027ba064">AVCodecContext.refcounted_frames</a> is set to 1, the frame is reference counted and the returned reference belongs to the caller. The caller must release the frame using av_frame_unref() when the frame is no longer needed. The caller may safely write to the frame if av_frame_is_writable() returns 1. When <a class="el" href="struct_a_v_codec_context.html#ab16d1e0c729a7b63d918d5ec027ba064">AVCodecContext.refcounted_frames</a> is set to 0, the returned reference belongs to the decoder and is valid only until the next call to this function or until closing the decoder. The caller may not write to it. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">got_frame_ptr</td><td>Zero if no frame could be decoded, otherwise it is non-zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">avpkt</td><td>The input <a class="el" href="struct_a_v_packet.html">AVPacket</a> containing the input buffer. At least avpkt-&gt;data and avpkt-&gt;size should be set. Some decoders might also require additional fields to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative error code is returned if an error occurred during decoding, otherwise the number of bytes consumed from the input <a class="el" href="struct_a_v_packet.html">AVPacket</a> is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga47db1b7f294b9f92684401b9c66a7c4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avcodec_decode_subtitle2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_v_subtitle.html">AVSubtitle</a> *&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>got_sub_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_v_packet.html">AVPacket</a> *&#160;</td>
          <td class="paramname"><em>avpkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decode a subtitle message. Return a negative value on error, otherwise return the number of bytes used. If no subtitle could be decompressed, got_sub_ptr is zero. Otherwise, the subtitle is stored in *sub. Note that CODEC_CAP_DR1 is not available for subtitle codecs. This is for simplicity, because the performance difference is expect to be negligible and reusing a get_buffer written for video codecs would probably perform badly due to a potentially very different allocation pattern.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">avctx</td><td>the codec context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sub</td><td>The <a class="el" href="struct_a_v_subtitle.html">AVSubtitle</a> in which the decoded subtitle will be stored, must be freed with avsubtitle_free if *got_sub_ptr is set. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">got_sub_ptr</td><td>Zero if no subtitle could be decompressed, otherwise, it is nonzero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">avpkt</td><td>The input <a class="el" href="struct_a_v_packet.html">AVPacket</a> containing the input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e4048fd6893d4a001bdaa3d251f3c03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avcodec_decode_video2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_v_frame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>picture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>got_picture_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_v_packet.html">AVPacket</a> *&#160;</td>
          <td class="paramname"><em>avpkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decode the video frame of size avpkt-&gt;size from avpkt-&gt;data into picture. Some decoders may support multiple frames in a single <a class="el" href="struct_a_v_packet.html">AVPacket</a>, such decoders would then just decode the first frame.</p>
<dl class="section warning"><dt>Warning</dt><dd>The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.</dd>
<dd>
The end of the input buffer buf should be set to 0 to ensure that no overreading happens for damaged MPEG streams.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You might have to align the input buffer avpkt-&gt;data. The alignment requirements depend on the CPU: on some CPUs it isn't necessary at all, on others it won't work at all if not aligned and on others it will work but it will have an impact on performance.</dd></dl>
<p>In practice, avpkt-&gt;data should have 4 byte alignment at minimum.</p>
<dl class="section note"><dt>Note</dt><dd>Codecs which have the CODEC_CAP_DELAY capability set have a delay between input and output, these need to be fed with avpkt-&gt;data=NULL, avpkt-&gt;size=0 at the end to return the remaining frames.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">avctx</td><td>the codec context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">picture</td><td>The <a class="el" href="struct_a_v_frame.html">AVFrame</a> in which the decoded video frame will be stored. Use av_frame_alloc() to get an <a class="el" href="struct_a_v_frame.html">AVFrame</a>. The codec will allocate memory for the actual bitmap by calling the <a class="el" href="struct_a_v_codec_context.html#a7c93198032a3a728b13cb7d7e637d295">AVCodecContext.get_buffer2()</a> callback. When <a class="el" href="struct_a_v_codec_context.html#ab16d1e0c729a7b63d918d5ec027ba064">AVCodecContext.refcounted_frames</a> is set to 1, the frame is reference counted and the returned reference belongs to the caller. The caller must release the frame using av_frame_unref() when the frame is no longer needed. The caller may safely write to the frame if av_frame_is_writable() returns 1. When <a class="el" href="struct_a_v_codec_context.html#ab16d1e0c729a7b63d918d5ec027ba064">AVCodecContext.refcounted_frames</a> is set to 0, the returned reference belongs to the decoder and is valid only until the next call to this function or until closing the decoder. The caller may not write to it.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">avpkt</td><td>The input AVpacket containing the input buffer. You can create such packet with <a class="el" href="group__lavc__packet.html#gac9cb9756175b96e7441575803757fb73">av_init_packet()</a> and by then setting data and size, some decoders might in addition need other fields like flags&amp;AV_PKT_FLAG_KEY. All decoders are designed to use the least fields possible. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">got_picture_ptr</td><td>Zero if no frame could be decompressed, otherwise, it is nonzero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On error a negative value is returned, otherwise the number of bytes used or zero if no frame could be decompressed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga09dee227d3666720eff1f6913d11699d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avcodec_default_get_buffer2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_v_frame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default callback for <a class="el" href="struct_a_v_codec_context.html#a7c93198032a3a728b13cb7d7e637d295">AVCodecContext.get_buffer2()</a>. It is made public so it can be called by custom get_buffer2() implementations for decoders without CODEC_CAP_DR1 set. </p>

</div>
</div>
<a class="anchor" id="ga19a0ca553277f019dd5b0fec6e1f9dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_v_codec.html">AVCodec</a>* avcodec_find_decoder </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a registered decoder with a matching codec ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>AVCodecID of the requested decoder </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A decoder if one was found, NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga776f2359007e8457799503068419e791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_v_codec.html">AVCodec</a>* avcodec_find_decoder_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a registered decoder with the specified name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the requested decoder </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A decoder if one was found, NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46b124de35e7292bb681fa1ad55de695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned avcodec_get_edge_width </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the amount of padding in pixels which the get_buffer callback must provide around the edge of the image for codecs which do not have the CODEC_FLAG_EMU_EDGE flag.</p>
<dl class="section return"><dt>Returns</dt><dd>Required padding in pixels. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Jan 11 2014 18:32:15 for ofxLibav by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
