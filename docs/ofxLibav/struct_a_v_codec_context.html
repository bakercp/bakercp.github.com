<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ofxLibav: AVCodecContext Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ofxLibav
   </div>
   <div id="projectbrief">A small wrapper for libav.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('struct_a_v_codec_context.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_a_v_codec_context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AVCodecContext Struct Reference<div class="ingroups"><a class="el" href="group__lavc__core.html">Core functions/structures.</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="avcodec_8h_source.html">avcodec.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a90622d3af2a9abba986a1c9f7ca21b16"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_a_v_class.html">AVClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a90622d3af2a9abba986a1c9f7ca21b16">av_class</a></td></tr>
<tr class="separator:a90622d3af2a9abba986a1c9f7ca21b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9e4467c3394228bc3c9f308a42303c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f9e4467c3394228bc3c9f308a42303c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>log_level_offset</b></td></tr>
<tr class="separator:a7f9e4467c3394228bc3c9f308a42303c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f99ca3115c44e6d7772c9384faf15e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f99ca3115c44e6d7772c9384faf15e6"></a>
enum <a class="el" href="group__lavu__misc.html#ga9a84bba4713dfced21a1a56163be1f48">AVMediaType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>codec_type</b></td></tr>
<tr class="separator:a3f99ca3115c44e6d7772c9384faf15e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e606effa68724cae2ef5cc05f7fd9cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e606effa68724cae2ef5cc05f7fd9cb"></a>
const struct <a class="el" href="struct_a_v_codec.html">AVCodec</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>codec</b></td></tr>
<tr class="separator:a6e606effa68724cae2ef5cc05f7fd9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a85cb13e730b57b121e7aac3306ec87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a85cb13e730b57b121e7aac3306ec87"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>codec_name</b> [32]</td></tr>
<tr class="separator:a8a85cb13e730b57b121e7aac3306ec87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5f65d6099fd8339c1580c091777223"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc5f65d6099fd8339c1580c091777223"></a>
enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td><td class="memItemRight" valign="bottom"><b>codec_id</b></td></tr>
<tr class="separator:adc5f65d6099fd8339c1580c091777223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c974557671dd459674b170c5e64d79a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a2c974557671dd459674b170c5e64d79a">codec_tag</a></td></tr>
<tr class="separator:a2c974557671dd459674b170c5e64d79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae008a28c9ab5820840bd67982019e98d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ae008a28c9ab5820840bd67982019e98d">stream_codec_tag</a></td></tr>
<tr class="separator:ae008a28c9ab5820840bd67982019e98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3379123060ad8cc9c321c29af4f8360"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3379123060ad8cc9c321c29af4f8360"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>priv_data</b></td></tr>
<tr class="separator:af3379123060ad8cc9c321c29af4f8360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffc0091dc3138015b53107c8ffb04af"><td class="memItemLeft" align="right" valign="top">struct AVCodecInternal *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aeffc0091dc3138015b53107c8ffb04af">internal</a></td></tr>
<tr class="separator:aeffc0091dc3138015b53107c8ffb04af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9c4495feeedde28c1e908d76b7b9f5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aab9c4495feeedde28c1e908d76b7b9f5">opaque</a></td></tr>
<tr class="separator:aab9c4495feeedde28c1e908d76b7b9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9214d5af3e98ea7f1d4e94be6a522de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ad9214d5af3e98ea7f1d4e94be6a522de">bit_rate</a></td></tr>
<tr class="separator:ad9214d5af3e98ea7f1d4e94be6a522de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f37abbfc9d4630aa7fd44b9a1ebb21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a65f37abbfc9d4630aa7fd44b9a1ebb21">bit_rate_tolerance</a></td></tr>
<tr class="separator:a65f37abbfc9d4630aa7fd44b9a1ebb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209f5ec60cb5f0b0a4962f4c5c5bb541"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a209f5ec60cb5f0b0a4962f4c5c5bb541">global_quality</a></td></tr>
<tr class="separator:a209f5ec60cb5f0b0a4962f4c5c5bb541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa401ca663644caa51ede1889659c23d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aa401ca663644caa51ede1889659c23d6">compression_level</a></td></tr>
<tr class="separator:aa401ca663644caa51ede1889659c23d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb01e291550fa3fb96188af4d494587e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#abb01e291550fa3fb96188af4d494587e">flags</a></td></tr>
<tr class="separator:abb01e291550fa3fb96188af4d494587e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1944f9a4f8f2e123c087e1fe7613d571"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a1944f9a4f8f2e123c087e1fe7613d571">flags2</a></td></tr>
<tr class="separator:a1944f9a4f8f2e123c087e1fe7613d571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe964316aaaa61967b012efdcced79c4"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#abe964316aaaa61967b012efdcced79c4">extradata</a></td></tr>
<tr class="separator:abe964316aaaa61967b012efdcced79c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae246ca7a1c72c151891ed0599e8dbfba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae246ca7a1c72c151891ed0599e8dbfba"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>extradata_size</b></td></tr>
<tr class="separator:ae246ca7a1c72c151891ed0599e8dbfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bfeb9fa5840aac090e2b0bd0ef7589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_v_rational.html">AVRational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ab7bfeb9fa5840aac090e2b0bd0ef7589">time_base</a></td></tr>
<tr class="separator:ab7bfeb9fa5840aac090e2b0bd0ef7589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c62b9c1528a272923ea2a4b86dea31a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a5c62b9c1528a272923ea2a4b86dea31a">ticks_per_frame</a></td></tr>
<tr class="separator:a5c62b9c1528a272923ea2a4b86dea31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948993adfdfcd64b81dad1151fe50f33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a948993adfdfcd64b81dad1151fe50f33">delay</a></td></tr>
<tr class="separator:a948993adfdfcd64b81dad1151fe50f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8f46461754e8abea0847dcbc41b956"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a0d8f46461754e8abea0847dcbc41b956">width</a></td></tr>
<tr class="separator:a0d8f46461754e8abea0847dcbc41b956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0449afd803eb107bd4dbc8b5ea22e363"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0449afd803eb107bd4dbc8b5ea22e363"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>height</b></td></tr>
<tr class="separator:a0449afd803eb107bd4dbc8b5ea22e363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c157e97ff15d46e898a538c6bc7f09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ae3c157e97ff15d46e898a538c6bc7f09">coded_width</a></td></tr>
<tr class="separator:ae3c157e97ff15d46e898a538c6bc7f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ebb76836ef4cd9822b5077c17b33d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2ebb76836ef4cd9822b5077c17b33d0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>coded_height</b></td></tr>
<tr class="separator:ab2ebb76836ef4cd9822b5077c17b33d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6b3f1fcbdcc2ad9f4dbb4370496e38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a9b6b3f1fcbdcc2ad9f4dbb4370496e38">gop_size</a></td></tr>
<tr class="separator:a9b6b3f1fcbdcc2ad9f4dbb4370496e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0425c77b3d06d71e5db88b1d7e1b37f2"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5">AVPixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a0425c77b3d06d71e5db88b1d7e1b37f2">pix_fmt</a></td></tr>
<tr class="separator:a0425c77b3d06d71e5db88b1d7e1b37f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae969fc4cb4ac9ca5c61f7f7c6f78e14d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ae969fc4cb4ac9ca5c61f7f7c6f78e14d">me_method</a></td></tr>
<tr class="separator:ae969fc4cb4ac9ca5c61f7f7c6f78e14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e68a5af5b69e58c6b033a9e3ea007f"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aa6e68a5af5b69e58c6b033a9e3ea007f">draw_horiz_band</a> )(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *s, const <a class="el" href="struct_a_v_frame.html">AVFrame</a> *src, int offset[AV_NUM_DATA_POINTERS], int y, int type, int height)</td></tr>
<tr class="separator:aa6e68a5af5b69e58c6b033a9e3ea007f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85c5a0e81e9f97c063881148edc28b7"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5">AVPixelFormat</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ae85c5a0e81e9f97c063881148edc28b7">get_format</a> )(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *s, const enum <a class="el" href="pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5">AVPixelFormat</a> *fmt)</td></tr>
<tr class="separator:ae85c5a0e81e9f97c063881148edc28b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5334a611a3e2a6a653805bb9e2d4d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a3e5334a611a3e2a6a653805bb9e2d4d4">max_b_frames</a></td></tr>
<tr class="separator:a3e5334a611a3e2a6a653805bb9e2d4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a7fdf60f853d9140bbe1204a66efb2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a40a7fdf60f853d9140bbe1204a66efb2">b_quant_factor</a></td></tr>
<tr class="separator:a40a7fdf60f853d9140bbe1204a66efb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa243eb5ac9606ee7d0e1e8402ffcb289"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aa243eb5ac9606ee7d0e1e8402ffcb289">rc_strategy</a></td></tr>
<tr class="separator:aa243eb5ac9606ee7d0e1e8402ffcb289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64625af3f41e59bf3cf58be910a0cd3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64625af3f41e59bf3cf58be910a0cd3b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>b_frame_strategy</b></td></tr>
<tr class="separator:a64625af3f41e59bf3cf58be910a0cd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a2ef78cf186083c2c676dda8e226db"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a31a2ef78cf186083c2c676dda8e226db">b_quant_offset</a></td></tr>
<tr class="separator:a31a2ef78cf186083c2c676dda8e226db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686a77363668795c15c87b532cc455fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a686a77363668795c15c87b532cc455fa">has_b_frames</a></td></tr>
<tr class="separator:a686a77363668795c15c87b532cc455fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee77728beef26e1b3b6ff3cc9b27433"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a1ee77728beef26e1b3b6ff3cc9b27433">mpeg_quant</a></td></tr>
<tr class="separator:a1ee77728beef26e1b3b6ff3cc9b27433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7017818f06f053f2e63fe759b30eb1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aef7017818f06f053f2e63fe759b30eb1">i_quant_factor</a></td></tr>
<tr class="separator:aef7017818f06f053f2e63fe759b30eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9b149e17b9e28823ab3cf9732b990d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#afe9b149e17b9e28823ab3cf9732b990d">i_quant_offset</a></td></tr>
<tr class="separator:afe9b149e17b9e28823ab3cf9732b990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14fedf2fb0f6bda26a1badae5f8aeb4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ae14fedf2fb0f6bda26a1badae5f8aeb4">lumi_masking</a></td></tr>
<tr class="separator:ae14fedf2fb0f6bda26a1badae5f8aeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fccee6f69d7ddf5c01d3042bd2772b3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a8fccee6f69d7ddf5c01d3042bd2772b3">temporal_cplx_masking</a></td></tr>
<tr class="separator:a8fccee6f69d7ddf5c01d3042bd2772b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79ff5dc9b33e370267f406dd2d5dc67"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#af79ff5dc9b33e370267f406dd2d5dc67">spatial_cplx_masking</a></td></tr>
<tr class="separator:af79ff5dc9b33e370267f406dd2d5dc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906b4bb56c38c49ef2de171ccdc55e30"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a906b4bb56c38c49ef2de171ccdc55e30">p_masking</a></td></tr>
<tr class="separator:a906b4bb56c38c49ef2de171ccdc55e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bc3962f63a607a7d26d927f9bffb10"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a94bc3962f63a607a7d26d927f9bffb10">dark_masking</a></td></tr>
<tr class="separator:a94bc3962f63a607a7d26d927f9bffb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab4f688d837387c83315fba6027a43a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a5ab4f688d837387c83315fba6027a43a">slice_count</a></td></tr>
<tr class="separator:a5ab4f688d837387c83315fba6027a43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe2f66459911679409d0b223fcbd522"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#abfe2f66459911679409d0b223fcbd522">prediction_method</a></td></tr>
<tr class="separator:abfe2f66459911679409d0b223fcbd522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd75624ca647d2ac04b20c1eb7352e6"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aedd75624ca647d2ac04b20c1eb7352e6">slice_offset</a></td></tr>
<tr class="separator:aedd75624ca647d2ac04b20c1eb7352e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5252d34fbce300228d4dbda19a8c3293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_v_rational.html">AVRational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a5252d34fbce300228d4dbda19a8c3293">sample_aspect_ratio</a></td></tr>
<tr class="separator:a5252d34fbce300228d4dbda19a8c3293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184b7563344db253540f222d8d023ae1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a184b7563344db253540f222d8d023ae1">me_cmp</a></td></tr>
<tr class="separator:a184b7563344db253540f222d8d023ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d47cbb639922fee05ce6057d95457c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a76d47cbb639922fee05ce6057d95457c">me_sub_cmp</a></td></tr>
<tr class="separator:a76d47cbb639922fee05ce6057d95457c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99286e29b23e56cc65f7877102ee876f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a99286e29b23e56cc65f7877102ee876f">mb_cmp</a></td></tr>
<tr class="separator:a99286e29b23e56cc65f7877102ee876f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa136d238dbf5ea7085f6117b59e5d5eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aa136d238dbf5ea7085f6117b59e5d5eb">ildct_cmp</a></td></tr>
<tr class="separator:aa136d238dbf5ea7085f6117b59e5d5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fe8a6a05a20ef02eb49a46f774fb2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a41fe8a6a05a20ef02eb49a46f774fb2b">dia_size</a></td></tr>
<tr class="separator:a41fe8a6a05a20ef02eb49a46f774fb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca6bf3e2949e617cac66498779e6103"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a7ca6bf3e2949e617cac66498779e6103">last_predictor_count</a></td></tr>
<tr class="separator:a7ca6bf3e2949e617cac66498779e6103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ad25261c3edb8ad2c6bbbf68d71e58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a89ad25261c3edb8ad2c6bbbf68d71e58">pre_me</a></td></tr>
<tr class="separator:a89ad25261c3edb8ad2c6bbbf68d71e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05e5676655afdc05a83c06a90f3eea7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ac05e5676655afdc05a83c06a90f3eea7">me_pre_cmp</a></td></tr>
<tr class="separator:ac05e5676655afdc05a83c06a90f3eea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0eacb07c8a7a5b231d64c70c88645ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ae0eacb07c8a7a5b231d64c70c88645ff">pre_dia_size</a></td></tr>
<tr class="separator:ae0eacb07c8a7a5b231d64c70c88645ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad6d8644e00de2ecb636546d2e45121"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a3ad6d8644e00de2ecb636546d2e45121">me_subpel_quality</a></td></tr>
<tr class="separator:a3ad6d8644e00de2ecb636546d2e45121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3a0bbdc42a993a83222a79ea08b6de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#abd3a0bbdc42a993a83222a79ea08b6de">dtg_active_format</a></td></tr>
<tr class="separator:abd3a0bbdc42a993a83222a79ea08b6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16d78b369781e09d14343788284300a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ad16d78b369781e09d14343788284300a">me_range</a></td></tr>
<tr class="separator:ad16d78b369781e09d14343788284300a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4a8098f06ceed349a7a9f2eb1c4ee1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#acb4a8098f06ceed349a7a9f2eb1c4ee1">intra_quant_bias</a></td></tr>
<tr class="separator:acb4a8098f06ceed349a7a9f2eb1c4ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a0b83c4bf22c652b494759e6385867"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a07a0b83c4bf22c652b494759e6385867">inter_quant_bias</a></td></tr>
<tr class="separator:a07a0b83c4bf22c652b494759e6385867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce5f24ee2312281a68b40428b384bc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a2ce5f24ee2312281a68b40428b384bc8">slice_flags</a></td></tr>
<tr class="separator:a2ce5f24ee2312281a68b40428b384bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c6160724b39b5dc0a3994eaab5a3a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a13c6160724b39b5dc0a3994eaab5a3a8">xvmc_acceleration</a></td></tr>
<tr class="separator:a13c6160724b39b5dc0a3994eaab5a3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66af0e26734255f1eacabd7d67558482"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a66af0e26734255f1eacabd7d67558482">mb_decision</a></td></tr>
<tr class="separator:a66af0e26734255f1eacabd7d67558482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c2db3596802edecafa24e494b33879"><td class="memItemLeft" align="right" valign="top">uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ab2c2db3596802edecafa24e494b33879">intra_matrix</a></td></tr>
<tr class="separator:ab2c2db3596802edecafa24e494b33879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eab2273bf713aca6284b8ba06ead659"><td class="memItemLeft" align="right" valign="top">uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a5eab2273bf713aca6284b8ba06ead659">inter_matrix</a></td></tr>
<tr class="separator:a5eab2273bf713aca6284b8ba06ead659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a01e9774060c41493c97d43b9737061"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a5a01e9774060c41493c97d43b9737061">scenechange_threshold</a></td></tr>
<tr class="separator:a5a01e9774060c41493c97d43b9737061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04065050e4f8f9b6ca6a302b4a857bbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a04065050e4f8f9b6ca6a302b4a857bbf">noise_reduction</a></td></tr>
<tr class="separator:a04065050e4f8f9b6ca6a302b4a857bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c2d0cc22f31003bef8a472aa70fd7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aa7c2d0cc22f31003bef8a472aa70fd7f">me_threshold</a></td></tr>
<tr class="separator:aa7c2d0cc22f31003bef8a472aa70fd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bacd97ea1b5f7c449ebb06ed526f2c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a3bacd97ea1b5f7c449ebb06ed526f2c9">mb_threshold</a></td></tr>
<tr class="separator:a3bacd97ea1b5f7c449ebb06ed526f2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c1b3cd296d19d7492e554d987d00e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ac5c1b3cd296d19d7492e554d987d00e7">intra_dc_precision</a></td></tr>
<tr class="separator:ac5c1b3cd296d19d7492e554d987d00e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023de607be08e4e8e9b15349f3a1f446"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a023de607be08e4e8e9b15349f3a1f446">skip_top</a></td></tr>
<tr class="separator:a023de607be08e4e8e9b15349f3a1f446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39075ccc5ac22a20d315259e8ad8458"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ae39075ccc5ac22a20d315259e8ad8458">skip_bottom</a></td></tr>
<tr class="separator:ae39075ccc5ac22a20d315259e8ad8458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab4d246910b59d598001e83b9cb2330"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#afab4d246910b59d598001e83b9cb2330">border_masking</a></td></tr>
<tr class="separator:afab4d246910b59d598001e83b9cb2330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a4d11439556b459cc0c833c8d9dc3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aa2a4d11439556b459cc0c833c8d9dc3d">mb_lmin</a></td></tr>
<tr class="separator:aa2a4d11439556b459cc0c833c8d9dc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec9ca08ce8cbc916ff71b6664a50428"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a3ec9ca08ce8cbc916ff71b6664a50428">mb_lmax</a></td></tr>
<tr class="separator:a3ec9ca08ce8cbc916ff71b6664a50428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ce781a285bd3688a501a888d652dbd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a90ce781a285bd3688a501a888d652dbd">me_penalty_compensation</a></td></tr>
<tr class="separator:a90ce781a285bd3688a501a888d652dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df462fdb6b38432ecfd37f30c1d082c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a4df462fdb6b38432ecfd37f30c1d082c">bidir_refine</a></td></tr>
<tr class="separator:a4df462fdb6b38432ecfd37f30c1d082c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c103eacc35d3d43c2022ac4ceb33a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a29c103eacc35d3d43c2022ac4ceb33a1">brd_scale</a></td></tr>
<tr class="separator:a29c103eacc35d3d43c2022ac4ceb33a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f920af17b8b15cc9d9465ecb732afcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a3f920af17b8b15cc9d9465ecb732afcb">keyint_min</a></td></tr>
<tr class="separator:a3f920af17b8b15cc9d9465ecb732afcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cb7241b4624dba761c8cf58fb2d5f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aa0cb7241b4624dba761c8cf58fb2d5f0">refs</a></td></tr>
<tr class="separator:aa0cb7241b4624dba761c8cf58fb2d5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0648de462329a899457c04f539e3782"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ad0648de462329a899457c04f539e3782">chromaoffset</a></td></tr>
<tr class="separator:ad0648de462329a899457c04f539e3782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc86ec1e352f31606d2124d88534997f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#abc86ec1e352f31606d2124d88534997f">scenechange_factor</a></td></tr>
<tr class="separator:abc86ec1e352f31606d2124d88534997f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f666a5ac597e723e0b64aad4133a02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aa1f666a5ac597e723e0b64aad4133a02">mv0_threshold</a></td></tr>
<tr class="separator:aa1f666a5ac597e723e0b64aad4133a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab061daa4576c7c17288a9aac7ee8d69b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ab061daa4576c7c17288a9aac7ee8d69b">b_sensitivity</a></td></tr>
<tr class="separator:ab061daa4576c7c17288a9aac7ee8d69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a41b3e5bde23b877799f6e72dac8ef3"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__core.html#gad384ee5a840bafd73daef08e6d9cafe7">AVColorPrimaries</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a3a41b3e5bde23b877799f6e72dac8ef3">color_primaries</a></td></tr>
<tr class="separator:a3a41b3e5bde23b877799f6e72dac8ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab649e8c599f5a0e2a30448e67a36deb6"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__core.html#gad4791ea14975f098b649db7fcd731ce6">AVColorTransferCharacteristic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ab649e8c599f5a0e2a30448e67a36deb6">color_trc</a></td></tr>
<tr class="separator:ab649e8c599f5a0e2a30448e67a36deb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd8caa7d40319324ce3d879a2edbd9f"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__core.html#gaff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a8cd8caa7d40319324ce3d879a2edbd9f">colorspace</a></td></tr>
<tr class="separator:a8cd8caa7d40319324ce3d879a2edbd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255bf7100a4ba6dcb6ee5d87740a4f35"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__core.html#ga3da0bf691418bc22c4bcbe6583ad589a">AVColorRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a255bf7100a4ba6dcb6ee5d87740a4f35">color_range</a></td></tr>
<tr class="separator:a255bf7100a4ba6dcb6ee5d87740a4f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60a0209642b5d74068cab0ac35a78b2"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__core.html#ga1f86ed1b6a420faccacf77c98db6c1ff">AVChromaLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ac60a0209642b5d74068cab0ac35a78b2">chroma_sample_location</a></td></tr>
<tr class="separator:ac60a0209642b5d74068cab0ac35a78b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4e6a78c0f08be43879644632e04b24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aff4e6a78c0f08be43879644632e04b24">slices</a></td></tr>
<tr class="separator:aff4e6a78c0f08be43879644632e04b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d222eeeb0b54ab462af363bcb9273bc"><td class="memItemLeft" align="right" valign="top">enum AVFieldOrder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a5d222eeeb0b54ab462af363bcb9273bc">field_order</a></td></tr>
<tr class="separator:a5d222eeeb0b54ab462af363bcb9273bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff0b000c463361e234af48d03aadfc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ff0b000c463361e234af48d03aadfc0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a8ff0b000c463361e234af48d03aadfc0">sample_rate</a></td></tr>
<tr class="memdesc:a8ff0b000c463361e234af48d03aadfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">samples per second <br/></td></tr>
<tr class="separator:a8ff0b000c463361e234af48d03aadfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e6c2cd1269caa7570575725c682a49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1e6c2cd1269caa7570575725c682a49"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ac1e6c2cd1269caa7570575725c682a49">channels</a></td></tr>
<tr class="memdesc:ac1e6c2cd1269caa7570575725c682a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of audio channels <br/></td></tr>
<tr class="separator:ac1e6c2cd1269caa7570575725c682a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdba69ea111e2a9d03fdaa7a46a4c45"><td class="memItemLeft" align="right" valign="top">enum AVSampleFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a1bdba69ea111e2a9d03fdaa7a46a4c45">sample_fmt</a></td></tr>
<tr class="memdesc:a1bdba69ea111e2a9d03fdaa7a46a4c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">sample format  <a href="#a1bdba69ea111e2a9d03fdaa7a46a4c45">More...</a><br/></td></tr>
<tr class="separator:a1bdba69ea111e2a9d03fdaa7a46a4c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec57f0d859a6df8b479cd93ca3a44a33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aec57f0d859a6df8b479cd93ca3a44a33">frame_size</a></td></tr>
<tr class="separator:aec57f0d859a6df8b479cd93ca3a44a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5a25a530d01c04491216c368a1a04a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a9e5a25a530d01c04491216c368a1a04a">frame_number</a></td></tr>
<tr class="separator:a9e5a25a530d01c04491216c368a1a04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56433cc80666ff63af59db4de5b5e45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ae56433cc80666ff63af59db4de5b5e45">block_align</a></td></tr>
<tr class="separator:ae56433cc80666ff63af59db4de5b5e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cc92cf09edd8fdf95018bf5e08b910"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ae2cc92cf09edd8fdf95018bf5e08b910">cutoff</a></td></tr>
<tr class="separator:ae2cc92cf09edd8fdf95018bf5e08b910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb08c575a79eb84fc4155dda88f46c06"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aeb08c575a79eb84fc4155dda88f46c06">channel_layout</a></td></tr>
<tr class="separator:aeb08c575a79eb84fc4155dda88f46c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c02c458deaa58cc603da038b6acab1b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a9c02c458deaa58cc603da038b6acab1b">request_channel_layout</a></td></tr>
<tr class="separator:a9c02c458deaa58cc603da038b6acab1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e07891360937493c8ece702a09e0d6"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__core.html#gadcff0a5957a99f6fdf1eec9d5a3fdfaf">AVAudioServiceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a37e07891360937493c8ece702a09e0d6">audio_service_type</a></td></tr>
<tr class="separator:a37e07891360937493c8ece702a09e0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f43cf7ebfe15119e93fa757572f4601"><td class="memItemLeft" align="right" valign="top">enum AVSampleFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a8f43cf7ebfe15119e93fa757572f4601">request_sample_fmt</a></td></tr>
<tr class="separator:a8f43cf7ebfe15119e93fa757572f4601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c93198032a3a728b13cb7d7e637d295"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a7c93198032a3a728b13cb7d7e637d295">get_buffer2</a> )(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *s, <a class="el" href="struct_a_v_frame.html">AVFrame</a> *frame, int <a class="el" href="struct_a_v_codec_context.html#abb01e291550fa3fb96188af4d494587e">flags</a>)</td></tr>
<tr class="separator:a7c93198032a3a728b13cb7d7e637d295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16d1e0c729a7b63d918d5ec027ba064"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ab16d1e0c729a7b63d918d5ec027ba064">refcounted_frames</a></td></tr>
<tr class="separator:ab16d1e0c729a7b63d918d5ec027ba064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf47505d34bd4b5a9292268f9aed1faa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf47505d34bd4b5a9292268f9aed1faa"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#acf47505d34bd4b5a9292268f9aed1faa">qcompress</a></td></tr>
<tr class="memdesc:acf47505d34bd4b5a9292268f9aed1faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">amount of qscale change between easy &amp; hard scenes (0.0-1.0) <br/></td></tr>
<tr class="separator:acf47505d34bd4b5a9292268f9aed1faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7ff44bfb16c8f4da1e7c1567964074"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf7ff44bfb16c8f4da1e7c1567964074"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#acf7ff44bfb16c8f4da1e7c1567964074">qblur</a></td></tr>
<tr class="memdesc:acf7ff44bfb16c8f4da1e7c1567964074"><td class="mdescLeft">&#160;</td><td class="mdescRight">amount of qscale smoothing over time (0.0-1.0) <br/></td></tr>
<tr class="separator:acf7ff44bfb16c8f4da1e7c1567964074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f63bc9141e25bf7f1cda0cef7cd4a60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a3f63bc9141e25bf7f1cda0cef7cd4a60">qmin</a></td></tr>
<tr class="separator:a3f63bc9141e25bf7f1cda0cef7cd4a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab015db3b7fcd227193a7c17283914187"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ab015db3b7fcd227193a7c17283914187">qmax</a></td></tr>
<tr class="separator:ab015db3b7fcd227193a7c17283914187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08becf306e0984857919f777c4c2ebdb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a08becf306e0984857919f777c4c2ebdb">max_qdiff</a></td></tr>
<tr class="separator:a08becf306e0984857919f777c4c2ebdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d7bef19235330f23d21cf65c01a956"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a86d7bef19235330f23d21cf65c01a956">rc_qsquish</a></td></tr>
<tr class="separator:a86d7bef19235330f23d21cf65c01a956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb9c866147b87f945dc25290db94423"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bb9c866147b87f945dc25290db94423"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>rc_qmod_amp</b></td></tr>
<tr class="separator:a3bb9c866147b87f945dc25290db94423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea3bb6334a7b2bbc4e762f35ca7f473"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ea3bb6334a7b2bbc4e762f35ca7f473"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>rc_qmod_freq</b></td></tr>
<tr class="separator:a0ea3bb6334a7b2bbc4e762f35ca7f473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15000607a7e2371162348bb35b0184c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a15000607a7e2371162348bb35b0184c1">rc_buffer_size</a></td></tr>
<tr class="separator:a15000607a7e2371162348bb35b0184c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5491e9920ab3df5fc32aa6de0cb03c22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a5491e9920ab3df5fc32aa6de0cb03c22">rc_override_count</a></td></tr>
<tr class="separator:a5491e9920ab3df5fc32aa6de0cb03c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaabc10c6216da54ddf1aa454d64418c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaabc10c6216da54ddf1aa454d64418c"></a>
<a class="el" href="struct_rc_override.html">RcOverride</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>rc_override</b></td></tr>
<tr class="separator:adaabc10c6216da54ddf1aa454d64418c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f58c561e939b0bbd9a149dafe5768eb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a5f58c561e939b0bbd9a149dafe5768eb">rc_eq</a></td></tr>
<tr class="separator:a5f58c561e939b0bbd9a149dafe5768eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055dd5071b96565ab541d4c775e7f1f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a055dd5071b96565ab541d4c775e7f1f3">rc_max_rate</a></td></tr>
<tr class="separator:a055dd5071b96565ab541d4c775e7f1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5829c395fd6328c258379f2c3c11d40d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a5829c395fd6328c258379f2c3c11d40d">rc_min_rate</a></td></tr>
<tr class="separator:a5829c395fd6328c258379f2c3c11d40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61eb50e6362b69b6efdf0031b79f2395"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61eb50e6362b69b6efdf0031b79f2395"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>rc_buffer_aggressivity</b></td></tr>
<tr class="separator:a61eb50e6362b69b6efdf0031b79f2395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ba8e7263aaf3526d5f92eb9ebb6d9c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ac2ba8e7263aaf3526d5f92eb9ebb6d9c">rc_initial_cplx</a></td></tr>
<tr class="separator:ac2ba8e7263aaf3526d5f92eb9ebb6d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023d28b8d65fe09ded1987cdea18dddb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a023d28b8d65fe09ded1987cdea18dddb">rc_max_available_vbv_use</a></td></tr>
<tr class="separator:a023d28b8d65fe09ded1987cdea18dddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7380222079393197e5d6fdce042b2dd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ab7380222079393197e5d6fdce042b2dd">rc_min_vbv_overflow_use</a></td></tr>
<tr class="separator:ab7380222079393197e5d6fdce042b2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7546ebfa9e9ffede316576dced7e150c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a7546ebfa9e9ffede316576dced7e150c">rc_initial_buffer_occupancy</a></td></tr>
<tr class="separator:a7546ebfa9e9ffede316576dced7e150c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d81542c08bf97f64a59a028c319995"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ad5d81542c08bf97f64a59a028c319995">coder_type</a></td></tr>
<tr class="separator:ad5d81542c08bf97f64a59a028c319995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac92b6deba952dc10e0b9ab0b6114fce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aac92b6deba952dc10e0b9ab0b6114fce">context_model</a></td></tr>
<tr class="separator:aac92b6deba952dc10e0b9ab0b6114fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad069371f433207634879772efadea00d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ad069371f433207634879772efadea00d">lmin</a></td></tr>
<tr class="separator:ad069371f433207634879772efadea00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac412361412d5c8a12203955fbde4433"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aac412361412d5c8a12203955fbde4433">lmax</a></td></tr>
<tr class="separator:aac412361412d5c8a12203955fbde4433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dde2cdd14c9456ab2490e5c4d0ebf3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a3dde2cdd14c9456ab2490e5c4d0ebf3b">frame_skip_threshold</a></td></tr>
<tr class="separator:a3dde2cdd14c9456ab2490e5c4d0ebf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af872ceacd21fa053421c235e8d796085"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#af872ceacd21fa053421c235e8d796085">frame_skip_factor</a></td></tr>
<tr class="separator:af872ceacd21fa053421c235e8d796085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd35c9a1dcd66e4b9e0f25c79806582"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a3fd35c9a1dcd66e4b9e0f25c79806582">frame_skip_exp</a></td></tr>
<tr class="separator:a3fd35c9a1dcd66e4b9e0f25c79806582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add38d9ccd0605790aaa87bf41d5e1a97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#add38d9ccd0605790aaa87bf41d5e1a97">frame_skip_cmp</a></td></tr>
<tr class="separator:add38d9ccd0605790aaa87bf41d5e1a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025940af0d5249418d6ac7e183fdd40f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a025940af0d5249418d6ac7e183fdd40f">trellis</a></td></tr>
<tr class="separator:a025940af0d5249418d6ac7e183fdd40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924de0a448b906ea6de674a3982d575e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a924de0a448b906ea6de674a3982d575e">min_prediction_order</a></td></tr>
<tr class="separator:a924de0a448b906ea6de674a3982d575e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a9a4ed9ea37576945eb6ef00ab3365"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ab4a9a4ed9ea37576945eb6ef00ab3365">max_prediction_order</a></td></tr>
<tr class="separator:ab4a9a4ed9ea37576945eb6ef00ab3365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c0dc7988a2d4ff291980001e0ceef9"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a18c0dc7988a2d4ff291980001e0ceef9">timecode_frame_start</a></td></tr>
<tr class="separator:a18c0dc7988a2d4ff291980001e0ceef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa616d35fc4a7282680feb21b18258e51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa616d35fc4a7282680feb21b18258e51"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>rtp_callback</b> )(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *avctx, void *data, int size, int mb_nb)</td></tr>
<tr class="separator:aa616d35fc4a7282680feb21b18258e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583019faf28da26e282be834cd9a7d8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a583019faf28da26e282be834cd9a7d8f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>rtp_payload_size</b></td></tr>
<tr class="separator:a583019faf28da26e282be834cd9a7d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746bd6985c9fa8763d7544c0041c66a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a746bd6985c9fa8763d7544c0041c66a9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mv_bits</b></td></tr>
<tr class="separator:a746bd6985c9fa8763d7544c0041c66a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91d7a57d14f1cc5d5fc413755aea3f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af91d7a57d14f1cc5d5fc413755aea3f0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>header_bits</b></td></tr>
<tr class="separator:af91d7a57d14f1cc5d5fc413755aea3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc43abf810bfbc0c9a4fb17ca4b2ec1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bc43abf810bfbc0c9a4fb17ca4b2ec1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>i_tex_bits</b></td></tr>
<tr class="separator:a6bc43abf810bfbc0c9a4fb17ca4b2ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afad86bb36a66785ba1da25ce557fb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3afad86bb36a66785ba1da25ce557fb1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>p_tex_bits</b></td></tr>
<tr class="separator:a3afad86bb36a66785ba1da25ce557fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f29029c23a73b768eb77b792f6e6547"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f29029c23a73b768eb77b792f6e6547"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>i_count</b></td></tr>
<tr class="separator:a2f29029c23a73b768eb77b792f6e6547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c7434aa338d941423b45034e2a7854"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9c7434aa338d941423b45034e2a7854"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>p_count</b></td></tr>
<tr class="separator:ae9c7434aa338d941423b45034e2a7854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801dcbc834a3afae4b98053b56855a98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a801dcbc834a3afae4b98053b56855a98"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>skip_count</b></td></tr>
<tr class="separator:a801dcbc834a3afae4b98053b56855a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1316f12a3e77a1e28044d537bb58cca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1316f12a3e77a1e28044d537bb58cca"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>misc_bits</b></td></tr>
<tr class="separator:ac1316f12a3e77a1e28044d537bb58cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffba99ce690996d839032cd3b0be299"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a9ffba99ce690996d839032cd3b0be299">frame_bits</a></td></tr>
<tr class="separator:a9ffba99ce690996d839032cd3b0be299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5bec27a856369ac81ccc9784f52e86"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a0f5bec27a856369ac81ccc9784f52e86">stats_out</a></td></tr>
<tr class="separator:a0f5bec27a856369ac81ccc9784f52e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee62148c5519301149f75e7296e84e1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a4ee62148c5519301149f75e7296e84e1">stats_in</a></td></tr>
<tr class="separator:a4ee62148c5519301149f75e7296e84e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4649a6454a0f784794b89afdc44da669"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a4649a6454a0f784794b89afdc44da669">workaround_bugs</a></td></tr>
<tr class="separator:a4649a6454a0f784794b89afdc44da669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3090804569341ca235e3adbdc03318d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a3090804569341ca235e3adbdc03318d2">strict_std_compliance</a></td></tr>
<tr class="separator:a3090804569341ca235e3adbdc03318d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268759f44c37eda9f79048bd0ee05ffc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a268759f44c37eda9f79048bd0ee05ffc">error_concealment</a></td></tr>
<tr class="separator:a268759f44c37eda9f79048bd0ee05ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c52e4da25b608b2b9a80af21bb86d58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a1c52e4da25b608b2b9a80af21bb86d58">debug</a></td></tr>
<tr class="separator:a1c52e4da25b608b2b9a80af21bb86d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad823755aadd6eec734c216dbb17f145d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ad823755aadd6eec734c216dbb17f145d">debug_mv</a></td></tr>
<tr class="separator:ad823755aadd6eec734c216dbb17f145d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9978d9bd6ac80a494ef1b78fe1d004f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#af9978d9bd6ac80a494ef1b78fe1d004f">err_recognition</a></td></tr>
<tr class="separator:af9978d9bd6ac80a494ef1b78fe1d004f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c09907902b41744c3ea60c89fd42fb"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a64c09907902b41744c3ea60c89fd42fb">reordered_opaque</a></td></tr>
<tr class="separator:a64c09907902b41744c3ea60c89fd42fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1030454a58273fd5ab88679b1eed7cc"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ab1030454a58273fd5ab88679b1eed7cc">hwaccel</a></td></tr>
<tr class="separator:ab1030454a58273fd5ab88679b1eed7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab222f7d747dfdceff0a76999e09648c0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ab222f7d747dfdceff0a76999e09648c0">hwaccel_context</a></td></tr>
<tr class="separator:ab222f7d747dfdceff0a76999e09648c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7a609f77fd8876c8433c3673e9f9d5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#acb7a609f77fd8876c8433c3673e9f9d5">error</a> [AV_NUM_DATA_POINTERS]</td></tr>
<tr class="separator:acb7a609f77fd8876c8433c3673e9f9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270c5551611475aebd7f9ce154d7f263"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a270c5551611475aebd7f9ce154d7f263">dct_algo</a></td></tr>
<tr class="separator:a270c5551611475aebd7f9ce154d7f263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b669e043c8b064fcf991fd71e16a870"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a8b669e043c8b064fcf991fd71e16a870">idct_algo</a></td></tr>
<tr class="separator:a8b669e043c8b064fcf991fd71e16a870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5273a8cf73ef598d632c6eee1379d5ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a5273a8cf73ef598d632c6eee1379d5ad">bits_per_coded_sample</a></td></tr>
<tr class="separator:a5273a8cf73ef598d632c6eee1379d5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889b84d5b3657df4a4e45b17b87848f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a889b84d5b3657df4a4e45b17b87848f5">bits_per_raw_sample</a></td></tr>
<tr class="separator:a889b84d5b3657df4a4e45b17b87848f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fb7f609330fe4688e19b2b5536ca4b"><td class="memItemLeft" align="right" valign="top">attribute_deprecated int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#af6fb7f609330fe4688e19b2b5536ca4b">lowres</a></td></tr>
<tr class="separator:af6fb7f609330fe4688e19b2b5536ca4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdebc347b4f74e0b9271ff37cabc96e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_v_frame.html">AVFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#afdebc347b4f74e0b9271ff37cabc96e8">coded_frame</a></td></tr>
<tr class="separator:afdebc347b4f74e0b9271ff37cabc96e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa852b6227d0778b62e9cc4034ad3720c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aa852b6227d0778b62e9cc4034ad3720c">thread_count</a></td></tr>
<tr class="separator:aa852b6227d0778b62e9cc4034ad3720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7651614f4309122981d70e06a4b42fcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a7651614f4309122981d70e06a4b42fcb">thread_type</a></td></tr>
<tr class="separator:a7651614f4309122981d70e06a4b42fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4579d94675579e1d46a591340f598f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a5f4579d94675579e1d46a591340f598f">active_thread_type</a></td></tr>
<tr class="separator:a5f4579d94675579e1d46a591340f598f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd9a6f252d615243d01198fd3957fd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a5bd9a6f252d615243d01198fd3957fd8">thread_safe_callbacks</a></td></tr>
<tr class="separator:a5bd9a6f252d615243d01198fd3957fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a905e1ec6b03f69f60a4e668561d677"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a0a905e1ec6b03f69f60a4e668561d677">execute</a> )(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c, int(*func)(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c2, void *arg), void *arg2, int *ret, int count, int size)</td></tr>
<tr class="separator:a0a905e1ec6b03f69f60a4e668561d677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add90d0081b10f937009c978236d718a3"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#add90d0081b10f937009c978236d718a3">execute2</a> )(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c, int(*func)(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c2, void *arg, int jobnr, int threadnr), void *arg2, int *ret, int count)</td></tr>
<tr class="separator:add90d0081b10f937009c978236d718a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad58544c5ce08c36b42f31f263bb51e4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#aad58544c5ce08c36b42f31f263bb51e4">thread_opaque</a></td></tr>
<tr class="separator:aad58544c5ce08c36b42f31f263bb51e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e1ed5a7828461239d017147a0c5959"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a01e1ed5a7828461239d017147a0c5959">nsse_weight</a></td></tr>
<tr class="separator:a01e1ed5a7828461239d017147a0c5959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abe7095de73df98df4895bf9e25fc6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a7abe7095de73df98df4895bf9e25fc6b">profile</a></td></tr>
<tr class="separator:a7abe7095de73df98df4895bf9e25fc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6927dc652ae6241f1dfdbad4e12d3a40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a6927dc652ae6241f1dfdbad4e12d3a40">level</a></td></tr>
<tr class="separator:a6927dc652ae6241f1dfdbad4e12d3a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be328131743a97103b89e028e62e771"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__decoding.html#ga352363bce7d3ed82c101b3bc001d1c16">AVDiscard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a6be328131743a97103b89e028e62e771">skip_loop_filter</a></td></tr>
<tr class="separator:a6be328131743a97103b89e028e62e771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d90275bfb1153a5b00ebc2dd32a689"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__decoding.html#ga352363bce7d3ed82c101b3bc001d1c16">AVDiscard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ac3d90275bfb1153a5b00ebc2dd32a689">skip_idct</a></td></tr>
<tr class="separator:ac3d90275bfb1153a5b00ebc2dd32a689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af869b808363998c80adf7df6a944a5a6"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__decoding.html#ga352363bce7d3ed82c101b3bc001d1c16">AVDiscard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#af869b808363998c80adf7df6a944a5a6">skip_frame</a></td></tr>
<tr class="separator:af869b808363998c80adf7df6a944a5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab781cbaef6311226481e65a7f1a6d049"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#ab781cbaef6311226481e65a7f1a6d049">subtitle_header</a></td></tr>
<tr class="separator:ab781cbaef6311226481e65a7f1a6d049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7c381913c9918caf6969fef8806694"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d7c381913c9918caf6969fef8806694"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>subtitle_header_size</b></td></tr>
<tr class="separator:a0d7c381913c9918caf6969fef8806694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ef4b9ff4f4af3de015d7d86960b172"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a68ef4b9ff4f4af3de015d7d86960b172">error_rate</a></td></tr>
<tr class="separator:a68ef4b9ff4f4af3de015d7d86960b172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa08a5123a4d8b9f3e5be90587c0bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_v_packet.html">AVPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#adfa08a5123a4d8b9f3e5be90587c0bfe">pkt</a></td></tr>
<tr class="separator:adfa08a5123a4d8b9f3e5be90587c0bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35469829873ff8e5444040323e8e1e59"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_codec_context.html#a35469829873ff8e5444040323e8e1e59">vbv_delay</a></td></tr>
<tr class="separator:a35469829873ff8e5444040323e8e1e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>main external API structure. New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. sizeof(AVCodecContext) must not be used outside libav*. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5f4579d94675579e1d46a591340f598f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::active_thread_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Which multithreading methods are in use by the codec.</p>
<ul>
<li>encoding: Set by libavcodec.</li>
<li>decoding: Set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="a37e07891360937493c8ece702a09e0d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__core.html#gadcff0a5957a99f6fdf1eec9d5a3fdfaf">AVAudioServiceType</a> AVCodecContext::audio_service_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of service that the audio stream conveys.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="a90622d3af2a9abba986a1c9f7ca21b16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_a_v_class.html">AVClass</a>* AVCodecContext::av_class</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>information on struct for av_log</p>
<ul>
<li>set by avcodec_alloc_context3 </li>
</ul>

</div>
</div>
<a class="anchor" id="a40a7fdf60f853d9140bbe1204a66efb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::b_quant_factor</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>qscale factor between IP and B-frames If &gt; 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset). If &lt; 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a31a2ef78cf186083c2c676dda8e226db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::b_quant_offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>qscale offset between IP and B-frames</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ab061daa4576c7c17288a9aac7ee8d69b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::b_sensitivity</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adjust sensitivity of b_frame_strategy 1.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a4df462fdb6b38432ecfd37f30c1d082c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::bidir_refine</td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ad9214d5af3e98ea7f1d4e94be6a522de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::bit_rate</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the average bitrate</p>
<ul>
<li>encoding: Set by user; unused for constant quantizer encoding.</li>
<li>decoding: Set by libavcodec. 0 or some bitrate if this info is available in the stream. </li>
</ul>

</div>
</div>
<a class="anchor" id="a65f37abbfc9d4630aa7fd44b9a1ebb21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::bit_rate_tolerance</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of bits the bitstream is allowed to diverge from the reference. the reference can be CBR (for CBR pass1) or VBR (for pass2)</p>
<ul>
<li>encoding: Set by user; unused for constant quantizer encoding.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a5273a8cf73ef598d632c6eee1379d5ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::bits_per_coded_sample</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>bits per sample/pixel from the demuxer (needed for huffyuv).</p>
<ul>
<li>encoding: Set by libavcodec.</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="a889b84d5b3657df4a4e45b17b87848f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::bits_per_raw_sample</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bits per sample/pixel of internal libavcodec pixel/sample format.</p>
<ul>
<li>encoding: set by user.</li>
<li>decoding: set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="ae56433cc80666ff63af59db4de5b5e45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::block_align</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of bytes per packet if constant and known or 0 Used by some WAV based audio codecs. </p>

</div>
</div>
<a class="anchor" id="afab4d246910b59d598001e83b9cb2330"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::border_masking</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Border processing masking, raises the quantizer for mbs on the borders of the picture.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a29c103eacc35d3d43c2022ac4ceb33a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::brd_scale</td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="aeb08c575a79eb84fc4155dda88f46c06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t AVCodecContext::channel_layout</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Audio channel layout.</p>
<ul>
<li>encoding: set by user.</li>
<li>decoding: set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="ac60a0209642b5d74068cab0ac35a78b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__core.html#ga1f86ed1b6a420faccacf77c98db6c1ff">AVChromaLocation</a> AVCodecContext::chroma_sample_location</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This defines the location of chroma samples.</p>
<ul>
<li>encoding: Set by user</li>
<li>decoding: Set by libavcodec </li>
</ul>

</div>
</div>
<a class="anchor" id="ad0648de462329a899457c04f539e3782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::chromaoffset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>chroma qp offset from luma</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a2c974557671dd459674b170c5e64d79a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int AVCodecContext::codec_tag</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fourcc (LSB first, so "ABCD" -&gt; ('D'&lt;&lt;24) + ('C'&lt;&lt;16) + ('B'&lt;&lt;8) + 'A'). This is used to work around some encoder bugs. A demuxer should set this to what is stored in the field used to identify the codec. If there are multiple such fields in a container then the demuxer should choose the one which maximizes the information about the used codec. If the codec tag field in a container is larger than 32 bits then the demuxer should remap the longer ID to 32 bits with a table or other structure. Alternatively a new extra_codec_tag + size could be added but for this a clear advantage must be demonstrated first.</p>
<ul>
<li>encoding: Set by user, if not then the default based on codec_id will be used.</li>
<li>decoding: Set by user, will be converted to uppercase by libavcodec during init. </li>
</ul>

</div>
</div>
<a class="anchor" id="afdebc347b4f74e0b9271ff37cabc96e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_v_frame.html">AVFrame</a>* AVCodecContext::coded_frame</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the picture in the bitstream</p>
<ul>
<li>encoding: Set by libavcodec.</li>
<li>decoding: Set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="ae3c157e97ff15d46e898a538c6bc7f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::coded_width</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bitstream width / height, may be different from width/height e.g. when the decoded frame is cropped before being output.</p>
<ul>
<li>encoding: unused</li>
<li>decoding: May be set by the user before opening the decoder if known e.g. from the container. During decoding, the decoder may overwrite those values as required. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad5d81542c08bf97f64a59a028c319995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::coder_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>coder type</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a3a41b3e5bde23b877799f6e72dac8ef3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__core.html#gad384ee5a840bafd73daef08e6d9cafe7">AVColorPrimaries</a> AVCodecContext::color_primaries</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Chromaticity coordinates of the source primaries.</p>
<ul>
<li>encoding: Set by user</li>
<li>decoding: Set by libavcodec </li>
</ul>

</div>
</div>
<a class="anchor" id="a255bf7100a4ba6dcb6ee5d87740a4f35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__core.html#ga3da0bf691418bc22c4bcbe6583ad589a">AVColorRange</a> AVCodecContext::color_range</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MPEG vs JPEG YUV range.</p>
<ul>
<li>encoding: Set by user</li>
<li>decoding: Set by libavcodec </li>
</ul>

</div>
</div>
<a class="anchor" id="ab649e8c599f5a0e2a30448e67a36deb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__core.html#gad4791ea14975f098b649db7fcd731ce6">AVColorTransferCharacteristic</a> AVCodecContext::color_trc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Color Transfer Characteristic.</p>
<ul>
<li>encoding: Set by user</li>
<li>decoding: Set by libavcodec </li>
</ul>

</div>
</div>
<a class="anchor" id="a8cd8caa7d40319324ce3d879a2edbd9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__core.html#gaff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a> AVCodecContext::colorspace</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>YUV colorspace type.</p>
<ul>
<li>encoding: Set by user</li>
<li>decoding: Set by libavcodec </li>
</ul>

</div>
</div>
<a class="anchor" id="aa401ca663644caa51ede1889659c23d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::compression_level</td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="aac92b6deba952dc10e0b9ab0b6114fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::context_model</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>context model</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ae2cc92cf09edd8fdf95018bf5e08b910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::cutoff</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Audio cutoff bandwidth (0 means "automatic")</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a94bc3962f63a607a7d26d927f9bffb10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::dark_masking</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>darkness masking (0-&gt; disabled)</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a270c5551611475aebd7f9ce154d7f263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::dct_algo</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DCT algorithm, see FF_DCT_* below</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a1c52e4da25b608b2b9a80af21bb86d58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::debug</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>debug</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad823755aadd6eec734c216dbb17f145d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::debug_mv</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>debug</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="a948993adfdfcd64b81dad1151fe50f33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::delay</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Codec delay.</p>
<p>Video: Number of frames the decoded output will be delayed relative to the encoded input.</p>
<p>Audio: For encoding, this is the number of "priming" samples added to the beginning of the stream. The decoded output will be delayed by this many samples relative to the input to the encoder. Note that this field is purely informational and does not directly affect the pts output by the encoder, which should always be based on the actual presentation time, including any delay. For decoding, this is the number of samples the decoder needs to output before the decoder's output is valid. When seeking, you should start decoding this many samples prior to your desired seek point.</p>
<ul>
<li>encoding: Set by libavcodec.</li>
<li>decoding: Set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="a41fe8a6a05a20ef02eb49a46f774fb2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::dia_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ME diamond size &amp; shape</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="aa6e68a5af5b69e58c6b033a9e3ea007f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* AVCodecContext::draw_horiz_band)(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *s, const <a class="el" href="struct_a_v_frame.html">AVFrame</a> *src, int offset[AV_NUM_DATA_POINTERS], int y, int type, int height)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If non NULL, 'draw_horiz_band' is called by the libavcodec decoder to draw a horizontal band. It improves cache usage. Not all codecs can do that. You must check the codec capabilities beforehand. When multithreading is used, it may be called from multiple threads at the same time; threads might draw different parts of the same <a class="el" href="struct_a_v_frame.html">AVFrame</a>, or multiple AVFrames, and there is no guarantee that slices will be drawn in order. The function is also used by hardware acceleration APIs. It is called at least once during frame decoding to pass the data needed for hardware render. In that mode instead of pixel data, <a class="el" href="struct_a_v_frame.html">AVFrame</a> points to a structure specific to the acceleration API. The application reads the structure and can change some fields to indicate progress or mark state.</p>
<ul>
<li>encoding: unused</li>
<li>decoding: Set by user. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the height of the slice </td></tr>
    <tr><td class="paramname">y</td><td>the y position of the slice </td></tr>
    <tr><td class="paramname">type</td><td>1-&gt;top field, 2-&gt;bottom field, 3-&gt;frame </td></tr>
    <tr><td class="paramname">offset</td><td>offset into the <a class="el" href="struct_a_v_frame.html#a1d0f65014a8d1bf78cec8cbed2304992">AVFrame.data</a> from which the slice should be read </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="abd3a0bbdc42a993a83222a79ea08b6de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::dtg_active_format</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DTG active format information (additional aspect ratio information only used in DVB MPEG-2 transport streams) 0 if not set.</p>
<ul>
<li>encoding: unused</li>
<li>decoding: Set by decoder. </li>
</ul>

</div>
</div>
<a class="anchor" id="af9978d9bd6ac80a494ef1b78fe1d004f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::err_recognition</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Error recognition; may misdetect some more or less valid parts as errors.</p>
<ul>
<li>encoding: unused</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="acb7a609f77fd8876c8433c3673e9f9d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t AVCodecContext::error[AV_NUM_DATA_POINTERS]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>error</p>
<ul>
<li>encoding: Set by libavcodec if flags&amp;CODEC_FLAG_PSNR.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a268759f44c37eda9f79048bd0ee05ffc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::error_concealment</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>error concealment flags</p>
<ul>
<li>encoding: unused</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="a68ef4b9ff4f4af3de015d7d86960b172"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::error_rate</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simulates errors in the bitstream to test error concealment.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a0a905e1ec6b03f69f60a4e668561d677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* AVCodecContext::execute)(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c, int(*func)(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c2, void *arg), void *arg2, int *ret, int count, int size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The codec may call this to execute several independent things. It will return only after finishing all tasks. The user may replace this with some multithreaded implementation, the default implementation will execute the parts serially. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of things to execute<ul>
<li>encoding: Set by libavcodec, user can override.</li>
<li>decoding: Set by libavcodec, user can override. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add90d0081b10f937009c978236d718a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* AVCodecContext::execute2)(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c, int(*func)(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c2, void *arg, int jobnr, int threadnr), void *arg2, int *ret, int count)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The codec may call this to execute several independent things. It will return only after finishing all tasks. The user may replace this with some multithreaded implementation, the default implementation will execute the parts serially. Also see avcodec_thread_init and e.g. the &ndash;enable-pthread configure option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>context passed also to func </td></tr>
    <tr><td class="paramname">count</td><td>the number of things to execute </td></tr>
    <tr><td class="paramname">arg2</td><td>argument passed unchanged to func </td></tr>
    <tr><td class="paramname">ret</td><td>return values of executed functions, must have space for "count" values. May be NULL. </td></tr>
    <tr><td class="paramname">func</td><td>function that will be called count times, with jobnr from 0 to count-1. threadnr will be in the range 0 to c-&gt;thread_count-1 &lt; MAX_THREADS and so that no two instances of func executing at the same time will have the same threadnr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>always 0 currently, but code should handle a future improvement where when any call to func returns &lt; 0 no further calls to func may be done and &lt; 0 is returned.<ul>
<li>encoding: Set by libavcodec, user can override.</li>
<li>decoding: Set by libavcodec, user can override. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="abe964316aaaa61967b012efdcced79c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* AVCodecContext::extradata</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>some codecs need / can use extradata like Huffman tables. mjpeg: Huffman tables rv10: additional flags mpeg4: global headers (they can be in the bitstream or here) The allocated memory should be FF_INPUT_BUFFER_PADDING_SIZE bytes larger than extradata_size to avoid prolems if it is read with the bitstream reader. The bytewise contents of extradata must not depend on the architecture or CPU endianness.</p>
<ul>
<li>encoding: Set/allocated/freed by libavcodec.</li>
<li>decoding: Set/allocated/freed by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5d222eeeb0b54ab462af363bcb9273bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum AVFieldOrder AVCodecContext::field_order</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Field order</p>
<ul>
<li>encoding: set by libavcodec</li>
<li>decoding: Set by libavcodec </li>
</ul>

</div>
</div>
<a class="anchor" id="abb01e291550fa3fb96188af4d494587e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::flags</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CODEC_FLAG_*.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1944f9a4f8f2e123c087e1fe7613d571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::flags2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CODEC_FLAG2_*</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="a9ffba99ce690996d839032cd3b0be299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::frame_bits</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of bits used for the previously encoded frame</p>
<ul>
<li>encoding: Set by libavcodec.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a9e5a25a530d01c04491216c368a1a04a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::frame_number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frame counter, set by libavcodec.</p>
<ul>
<li>decoding: total number of frames returned from the decoder so far.</li>
<li><p class="startli">encoding: total number of frames passed to the encoder so far.</p>
<dl class="section note"><dt>Note</dt><dd>the counter is not incremented if encoding/decoding resulted in an error. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="aec57f0d859a6df8b479cd93ca3a44a33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::frame_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of samples per channel in an audio frame.</p>
<ul>
<li>encoding: set by libavcodec in <a class="el" href="group__lavc__core.html#ga11f785a188d7d9df71621001465b0f1d">avcodec_open2()</a>. Each submitted frame except the last must contain exactly frame_size samples per channel. May be 0 when the codec has CODEC_CAP_VARIABLE_FRAME_SIZE set, then the frame size is not restricted.</li>
<li>decoding: may be set by some decoders to indicate constant frame size </li>
</ul>

</div>
</div>
<a class="anchor" id="add38d9ccd0605790aaa87bf41d5e1a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::frame_skip_cmp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>frame skip comparison function</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a3fd35c9a1dcd66e4b9e0f25c79806582"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::frame_skip_exp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>frame skip exponent</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="af872ceacd21fa053421c235e8d796085"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::frame_skip_factor</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>frame skip factor</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a3dde2cdd14c9456ab2490e5c4d0ebf3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::frame_skip_threshold</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>frame skip threshold</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a7c93198032a3a728b13cb7d7e637d295"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* AVCodecContext::get_buffer2)(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *s, <a class="el" href="struct_a_v_frame.html">AVFrame</a> *frame, int <a class="el" href="struct_a_v_codec_context.html#abb01e291550fa3fb96188af4d494587e">flags</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback is called at the beginning of each frame to get data buffer(s) for it. There may be one contiguous buffer for all the data or there may be a buffer per each data plane or anything in between. Each buffer must be reference-counted using the AVBuffer API.</p>
<p>The following fields will be set in the frame before this callback is called:</p>
<ul>
<li>format</li>
<li>width, height (video only)</li>
<li>sample_rate, channel_layout, nb_samples (audio only) Their values may differ from the corresponding values in <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a>. This callback must use the frame values, not the codec context values, to calculate the required buffer size.</li>
</ul>
<p>This callback must fill the following fields in the frame:</p>
<ul>
<li>data[]</li>
<li>linesize[]</li>
<li>extended_data:<ul>
<li>if the data is planar audio with more than 8 channels, then this callback must allocate and fill extended_data to contain all pointers to all data planes. data[] must hold as many pointers as it can. extended_data must be allocated with <a class="el" href="group__lavu__mem.html#gacbca30ebc510a7e4156d66e7aceb2dc8">av_malloc()</a> and will be freed in av_frame_unref().</li>
<li>otherwise exended_data must point to data</li>
</ul>
</li>
<li>buf[] must contain references to the buffers that contain the frame data.</li>
<li>extended_buf and nb_extended_buf must be allocated with <a class="el" href="group__lavu__mem.html#gacbca30ebc510a7e4156d66e7aceb2dc8">av_malloc()</a> by this callback and filled with the extra buffers if there are more buffers than buf[] can hold. extended_buf will be freed in av_frame_unref().</li>
</ul>
<p>If CODEC_CAP_DR1 is not set then <a class="el" href="struct_a_v_codec_context.html#a7c93198032a3a728b13cb7d7e637d295">get_buffer2()</a> must call <a class="el" href="group__lavc__decoding.html#ga09dee227d3666720eff1f6913d11699d">avcodec_default_get_buffer2()</a> instead of providing buffers allocated by some other means.</p>
<p>Each data plane must be aligned to the maximum required by the target CPU.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__lavc__decoding.html#ga09dee227d3666720eff1f6913d11699d">avcodec_default_get_buffer2()</a></dd></dl>
<p>Video:</p>
<p>If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused (read and/or written to if it is writable) later by libavcodec.</p>
<p>If CODEC_FLAG_EMU_EDGE is not set in s-&gt;flags, the buffer must contain an edge of the size returned by <a class="el" href="group__lavc__decoding.html#ga46b124de35e7292bb681fa1ad55de695">avcodec_get_edge_width()</a> on all sides.</p>
<p><a class="el" href="group__lavc__decoding.html#ga34e3269dc1b9e2c98e9371241722e7e2">avcodec_align_dimensions2()</a> should be used to find the required width and height, as they normally need to be rounded up to the next multiple of 16.</p>
<p>If frame multithreading is used and thread_safe_callbacks is set, this callback may be called from a different thread, but not from more than one at once. Does not need to be reentrant.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__lavc__decoding.html#ga34e3269dc1b9e2c98e9371241722e7e2">avcodec_align_dimensions2()</a></dd></dl>
<p>Audio:</p>
<p>Decoders request a buffer of a particular size by setting <a class="el" href="struct_a_v_frame.html#a02f45ab8191aea1660159f1e464237ea">AVFrame.nb_samples</a> prior to calling <a class="el" href="struct_a_v_codec_context.html#a7c93198032a3a728b13cb7d7e637d295">get_buffer2()</a>. The decoder may, however, utilize only part of the buffer by setting <a class="el" href="struct_a_v_frame.html#a02f45ab8191aea1660159f1e464237ea">AVFrame.nb_samples</a> to a smaller value in the output frame.</p>
<p>As a convenience, av_samples_get_buffer_size() and av_samples_fill_arrays() in libavutil may be used by custom <a class="el" href="struct_a_v_codec_context.html#a7c93198032a3a728b13cb7d7e637d295">get_buffer2()</a> functions to find the required data size and to fill data pointers and linesize. In <a class="el" href="struct_a_v_frame.html#aa52bfc6605f6a3059a0c3226cc0f6567">AVFrame.linesize</a>, only linesize[0] may be set for audio since all planes must be the same size.</p>
<dl class="section see"><dt>See Also</dt><dd>av_samples_get_buffer_size(), av_samples_fill_arrays()</dd></dl>
<ul>
<li>encoding: unused</li>
<li>decoding: Set by libavcodec, user can override. </li>
</ul>

</div>
</div>
<a class="anchor" id="ae85c5a0e81e9f97c063881148edc28b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5">AVPixelFormat</a>(* AVCodecContext::get_format)(struct <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *s, const enum <a class="el" href="pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5">AVPixelFormat</a> *fmt)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>callback to negotiate the pixelFormat </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>is the list of formats which are supported by the codec, it is terminated by -1 as 0 is a valid format, the formats are ordered by quality. The first is always the native one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chosen format<ul>
<li>encoding: unused</li>
<li>decoding: Set by user, if not set the native format will be chosen. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a209f5ec60cb5f0b0a4962f4c5c5bb541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::global_quality</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Global quality for codecs which cannot change it per frame. This should be proportional to MPEG-1/2/4 qscale.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a9b6b3f1fcbdcc2ad9f4dbb4370496e38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::gop_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the number of pictures in a group of pictures, or 0 for intra_only</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a686a77363668795c15c87b532cc455fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::has_b_frames</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the frame reordering buffer in the decoder. For MPEG-2 it is 1 IPB or 0 low delay IP.</p>
<ul>
<li>encoding: Set by libavcodec.</li>
<li>decoding: Set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="ab1030454a58273fd5ab88679b1eed7cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a>* AVCodecContext::hwaccel</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hardware accelerator in use</p>
<ul>
<li>encoding: unused.</li>
<li>decoding: Set by libavcodec </li>
</ul>

</div>
</div>
<a class="anchor" id="ab222f7d747dfdceff0a76999e09648c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* AVCodecContext::hwaccel_context</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hardware accelerator context. For some hardware accelerators, a global context needs to be provided by the user. In that case, this holds display-dependent data Libav cannot instantiate itself. Please refer to the Libav HW accelerator documentation to know how to fill this is. e.g. for VA API, this is a struct <a class="el" href="structvaapi__context.html">vaapi_context</a>.</p>
<ul>
<li>encoding: unused</li>
<li>decoding: Set by user </li>
</ul>

</div>
</div>
<a class="anchor" id="aef7017818f06f053f2e63fe759b30eb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::i_quant_factor</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>qscale factor between P and I-frames If &gt; 0 then the last p frame quantizer will be used (q= lastp_q*factor+offset). If &lt; 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="afe9b149e17b9e28823ab3cf9732b990d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::i_quant_offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>qscale offset between P and I-frames</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a8b669e043c8b064fcf991fd71e16a870"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::idct_algo</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IDCT algorithm, see FF_IDCT_* below.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa136d238dbf5ea7085f6117b59e5d5eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::ildct_cmp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>interlaced DCT comparison function</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a5eab2273bf713aca6284b8ba06ead659"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t* AVCodecContext::inter_matrix</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>custom inter quantization matrix</p>
<ul>
<li>encoding: Set by user, can be NULL.</li>
<li>decoding: Set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="a07a0b83c4bf22c652b494759e6385867"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::inter_quant_bias</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>inter quantizer bias</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="aeffc0091dc3138015b53107c8ffb04af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct AVCodecInternal* AVCodecContext::internal</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Private context used for internal data.</p>
<p>Unlike priv_data, this is not codec-specific. It is used in general libavcodec functions. </p>

</div>
</div>
<a class="anchor" id="ac5c1b3cd296d19d7492e554d987d00e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::intra_dc_precision</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>precision of the intra DC coefficient - 8</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ab2c2db3596802edecafa24e494b33879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t* AVCodecContext::intra_matrix</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>custom intra quantization matrix</p>
<ul>
<li>encoding: Set by user, can be NULL.</li>
<li>decoding: Set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="acb4a8098f06ceed349a7a9f2eb1c4ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::intra_quant_bias</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>intra quantizer bias</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a3f920af17b8b15cc9d9465ecb732afcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::keyint_min</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minimum GOP size</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a7ca6bf3e2949e617cac66498779e6103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::last_predictor_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>amount of previous MV predictors (2a+1 x 2a+1 square)</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a6927dc652ae6241f1dfdbad4e12d3a40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::level</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>level</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="aac412361412d5c8a12203955fbde4433"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::lmax</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum Lagrange multipler</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ad069371f433207634879772efadea00d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::lmin</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minimum Lagrange multipler</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="af6fb7f609330fe4688e19b2b5536ca4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute_deprecated int AVCodecContext::lowres</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>low resolution decoding, 1-&gt; 1/2 size, 2-&gt;1/4 size</p>
<ul>
<li>encoding: unused</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="ae14fedf2fb0f6bda26a1badae5f8aeb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::lumi_masking</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>luminance masking (0-&gt; disabled)</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a3e5334a611a3e2a6a653805bb9e2d4d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::max_b_frames</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum number of B-frames between non-B-frames Note: The output will be delayed by max_b_frames+1 relative to the input.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ab4a9a4ed9ea37576945eb6ef00ab3365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::max_prediction_order</td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a08becf306e0984857919f777c4c2ebdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::max_qdiff</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum quantizer difference between frames</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a99286e29b23e56cc65f7877102ee876f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::mb_cmp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>macroblock comparison function (not supported yet)</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a66af0e26734255f1eacabd7d67558482"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::mb_decision</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>macroblock decision mode</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a3ec9ca08ce8cbc916ff71b6664a50428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::mb_lmax</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum MB lagrange multipler</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="aa2a4d11439556b459cc0c833c8d9dc3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::mb_lmin</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minimum MB lagrange multipler</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a3bacd97ea1b5f7c449ebb06ed526f2c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::mb_threshold</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macroblock threshold below which the user specified macroblock types will be used.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a184b7563344db253540f222d8d023ae1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::me_cmp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>motion estimation comparison function</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ae969fc4cb4ac9ca5c61f7f7c6f78e14d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::me_method</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Motion estimation algorithm used for video coding. 1 (zero), 2 (full), 3 (log), 4 (phods), 5 (epzs), 6 (x1), 7 (hex), 8 (umh), 10 (tesa) [7, 8, 10 are x264 specific]</p>
<ul>
<li>encoding: MUST be set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a90ce781a285bd3688a501a888d652dbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::me_penalty_compensation</td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ac05e5676655afdc05a83c06a90f3eea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::me_pre_cmp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>motion estimation prepass comparison function</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ad16d78b369781e09d14343788284300a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::me_range</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum motion estimation search range in subpel units If 0 then no limit.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a76d47cbb639922fee05ce6057d95457c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::me_sub_cmp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>subpixel motion estimation comparison function</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a3ad6d8644e00de2ecb636546d2e45121"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::me_subpel_quality</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>subpel ME quality</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="aa7c2d0cc22f31003bef8a472aa70fd7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::me_threshold</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Motion estimation threshold below which no motion estimation is performed, but instead the user specified motion vectors are used.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a924de0a448b906ea6de674a3982d575e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::min_prediction_order</td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a1ee77728beef26e1b3b6ff3cc9b27433"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::mpeg_quant</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>0-&gt; h263 quant 1-&gt; mpeg quant</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="aa1f666a5ac597e723e0b64aad4133a02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::mv0_threshold</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Note: Value depends upon the compare function used for fullpel ME.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a04065050e4f8f9b6ca6a302b4a857bbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::noise_reduction</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>noise reduction strength</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a01e1ed5a7828461239d017147a0c5959"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::nsse_weight</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>noise vs. sse weight for the nsse comparsion function</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="aab9c4495feeedde28c1e908d76b7b9f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* AVCodecContext::opaque</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Private data of the user, can be used to carry app specific stuff.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="a906b4bb56c38c49ef2de171ccdc55e30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::p_masking</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>p block masking (0-&gt; disabled)</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a0425c77b3d06d71e5db88b1d7e1b37f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5">AVPixelFormat</a> AVCodecContext::pix_fmt</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pixel format, see AV_PIX_FMT_xxx. May be set by the demuxer if known from headers. May be overriden by the decoder if it knows better.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by user if known, overridden by libavcodec if known </li>
</ul>

</div>
</div>
<a class="anchor" id="adfa08a5123a4d8b9f3e5be90587c0bfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_v_packet.html">AVPacket</a>* AVCodecContext::pkt</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Current packet as passed into the decoder, to avoid having to pass the packet into every function. Currently only valid inside lavc and get/release_buffer callbacks.</p>
<ul>
<li>decoding: set by avcodec_decode_*, read by get_buffer() for setting pkt_pts</li>
<li>encoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ae0eacb07c8a7a5b231d64c70c88645ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::pre_dia_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ME prepass diamond size &amp; shape</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a89ad25261c3edb8ad2c6bbbf68d71e58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::pre_me</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prepass for motion estimation</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="abfe2f66459911679409d0b223fcbd522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::prediction_method</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prediction method (needed for huffyuv)</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a7abe7095de73df98df4895bf9e25fc6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::profile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>profile</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="ab015db3b7fcd227193a7c17283914187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::qmax</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum quantizer</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a3f63bc9141e25bf7f1cda0cef7cd4a60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::qmin</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minimum quantizer</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a15000607a7e2371162348bb35b0184c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::rc_buffer_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>decoder bitstream buffer size</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a5f58c561e939b0bbd9a149dafe5768eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* AVCodecContext::rc_eq</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>rate control equation</p>
<ul>
<li>encoding: Set by user</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a7546ebfa9e9ffede316576dced7e150c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::rc_initial_buffer_occupancy</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of bits which should be loaded into the rc buffer before decoding starts.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ac2ba8e7263aaf3526d5f92eb9ebb6d9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::rc_initial_cplx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>initial complexity for pass1 ratecontrol</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a023d28b8d65fe09ded1987cdea18dddb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::rc_max_available_vbv_use</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ratecontrol attempt to use, at maximum, </p>
<p>of what can be used without an underflow.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused. </li>
</ul>

</div>
</div>
<a class="anchor" id="a055dd5071b96565ab541d4c775e7f1f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::rc_max_rate</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum bitrate</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a5829c395fd6328c258379f2c3c11d40d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::rc_min_rate</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minimum bitrate</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ab7380222079393197e5d6fdce042b2dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::rc_min_vbv_overflow_use</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ratecontrol attempt to use, at least, </p>
<p>times the amount needed to prevent a vbv overflow.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5491e9920ab3df5fc32aa6de0cb03c22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::rc_override_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ratecontrol override, see <a class="el" href="struct_rc_override.html">RcOverride</a></p>
<ul>
<li>encoding: Allocated/set/freed by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a86d7bef19235330f23d21cf65c01a956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::rc_qsquish</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ratecontrol qmin qmax limiting method 0-&gt; clipping, 1-&gt; use a nice continuous function to limit qscale wthin qmin/qmax.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="aa243eb5ac9606ee7d0e1e8402ffcb289"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::rc_strategy</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>obsolete FIXME remove </p>

</div>
</div>
<a class="anchor" id="ab16d1e0c729a7b63d918d5ec027ba064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::refcounted_frames</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If non-zero, the decoded audio and video frames returned from <a class="el" href="group__lavc__decoding.html#ga3e4048fd6893d4a001bdaa3d251f3c03">avcodec_decode_video2()</a> and <a class="el" href="group__lavc__decoding.html#ga8847025a0f6cf472fe6305532329d5d6">avcodec_decode_audio4()</a> are reference-counted and are valid indefinitely. The caller must free them with av_frame_unref() when they are not needed anymore. Otherwise, the decoded frames must not be freed by the caller and are only valid until the next decode call.</p>
<ul>
<li>encoding: unused</li>
<li>decoding: set by the caller before <a class="el" href="group__lavc__core.html#ga11f785a188d7d9df71621001465b0f1d">avcodec_open2()</a>. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa0cb7241b4624dba761c8cf58fb2d5f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::refs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of reference frames</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by lavc. </li>
</ul>

</div>
</div>
<a class="anchor" id="a64c09907902b41744c3ea60c89fd42fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t AVCodecContext::reordered_opaque</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>opaque 64bit number (generally a PTS) that will be reordered and output in <a class="el" href="struct_a_v_frame.html#ab54a78c51318c8c678e545b1f3d6fddd">AVFrame.reordered_opaque</a> </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>in favor of pkt_pts<ul>
<li>encoding: unused</li>
<li>decoding: Set by user. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9c02c458deaa58cc603da038b6acab1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t AVCodecContext::request_channel_layout</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request decoder to use this channel layout if it can (0 for default)</p>
<ul>
<li>encoding: unused</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="a8f43cf7ebfe15119e93fa757572f4601"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum AVSampleFormat AVCodecContext::request_sample_fmt</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to request a sample format from the decoder.</p>
<ul>
<li>encoding: unused.</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5252d34fbce300228d4dbda19a8c3293"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_v_rational.html">AVRational</a> AVCodecContext::sample_aspect_ratio</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sample aspect ratio (0 if unknown) That is the width of a pixel divided by the height of the pixel. Numerator and denominator must be relatively prime and smaller than 256 for some video standards.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1bdba69ea111e2a9d03fdaa7a46a4c45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum AVSampleFormat AVCodecContext::sample_fmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sample format </p>
<p>audio sample format</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="abc86ec1e352f31606d2124d88534997f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::scenechange_factor</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplied by qscale for each frame and added to scene_change_score.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a5a01e9774060c41493c97d43b9737061"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::scenechange_threshold</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>scene change detection threshold 0 is default, larger means fewer detected scene changes.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ae39075ccc5ac22a20d315259e8ad8458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::skip_bottom</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of macroblock rows at the bottom which are skipped.</p>
<ul>
<li>encoding: unused</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="af869b808363998c80adf7df6a944a5a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__decoding.html#ga352363bce7d3ed82c101b3bc001d1c16">AVDiscard</a> AVCodecContext::skip_frame</td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>encoding: unused</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="ac3d90275bfb1153a5b00ebc2dd32a689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__decoding.html#ga352363bce7d3ed82c101b3bc001d1c16">AVDiscard</a> AVCodecContext::skip_idct</td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>encoding: unused</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="a6be328131743a97103b89e028e62e771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__decoding.html#ga352363bce7d3ed82c101b3bc001d1c16">AVDiscard</a> AVCodecContext::skip_loop_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>encoding: unused</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="a023de607be08e4e8e9b15349f3a1f446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::skip_top</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of macroblock rows at the top which are skipped.</p>
<ul>
<li>encoding: unused</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5ab4f688d837387c83315fba6027a43a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::slice_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>slice count</p>
<ul>
<li>encoding: Set by libavcodec.</li>
<li>decoding: Set by user (or 0). </li>
</ul>

</div>
</div>
<a class="anchor" id="a2ce5f24ee2312281a68b40428b384bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::slice_flags</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>slice flags</p>
<ul>
<li>encoding: unused</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="aedd75624ca647d2ac04b20c1eb7352e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* AVCodecContext::slice_offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>slice offsets in the frame in bytes</p>
<ul>
<li>encoding: Set/allocated by libavcodec.</li>
<li>decoding: Set/allocated by user (or NULL). </li>
</ul>

</div>
</div>
<a class="anchor" id="aff4e6a78c0f08be43879644632e04b24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::slices</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of slices. Indicates number of picture subdivisions. Used for parallelized decoding.</p>
<ul>
<li>encoding: Set by user</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="af79ff5dc9b33e370267f406dd2d5dc67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::spatial_cplx_masking</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>spatial complexity masking (0-&gt; disabled)</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a4ee62148c5519301149f75e7296e84e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* AVCodecContext::stats_in</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pass2 encoding statistics input buffer Concatenated stuff from stats_out of pass1 should be placed here.</p>
<ul>
<li>encoding: Allocated/set/freed by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a0f5bec27a856369ac81ccc9784f52e86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* AVCodecContext::stats_out</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pass1 encoding statistics output buffer</p>
<ul>
<li>encoding: Set by libavcodec.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="ae008a28c9ab5820840bd67982019e98d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int AVCodecContext::stream_codec_tag</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fourcc from the AVI stream header (LSB first, so "ABCD" -&gt; ('D'&lt;&lt;24) + ('C'&lt;&lt;16) + ('B'&lt;&lt;8) + 'A'). This is used to work around some encoder bugs.</p>
<ul>
<li>encoding: unused</li>
<li>decoding: Set by user, will be converted to uppercase by libavcodec during init. </li>
</ul>

</div>
</div>
<a class="anchor" id="a3090804569341ca235e3adbdc03318d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::strict_std_compliance</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>strictly follow the standard (MPEG4, ...).</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by user. Setting this to STRICT or higher means the encoder and decoder will generally do stupid things, whereas setting it to unofficial or lower will mean the encoder might produce output that is not supported by all spec-compliant decoders. Decoders don't differentiate between normal, unofficial and experimental (that is, they always try to decode things when they can) unless they are explicitly asked to behave stupidly (=strictly conform to the specs) </li>
</ul>

</div>
</div>
<a class="anchor" id="ab781cbaef6311226481e65a7f1a6d049"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* AVCodecContext::subtitle_header</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Header containing style information for text subtitles. For SUBTITLE_ASS subtitle type, it should contain the whole ASS [Script Info] and [V4+ Styles] section, plus the [Events] line and the Format line following. It shouldn't include any Dialogue line.</p>
<ul>
<li>encoding: Set/allocated/freed by user (before <a class="el" href="group__lavc__core.html#ga11f785a188d7d9df71621001465b0f1d">avcodec_open2()</a>)</li>
<li>decoding: Set/allocated/freed by libavcodec (by <a class="el" href="group__lavc__core.html#ga11f785a188d7d9df71621001465b0f1d">avcodec_open2()</a>) </li>
</ul>

</div>
</div>
<a class="anchor" id="a8fccee6f69d7ddf5c01d3042bd2772b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AVCodecContext::temporal_cplx_masking</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>temporary complexity masking (0-&gt; disabled)</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="aa852b6227d0778b62e9cc4034ad3720c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::thread_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>thread count is used to decide how many independent tasks should be passed to <a class="el" href="struct_a_v_codec_context.html#a0a905e1ec6b03f69f60a4e668561d677">execute()</a></p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="aad58544c5ce08c36b42f31f263bb51e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* AVCodecContext::thread_opaque</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>thread opaque Can be used by <a class="el" href="struct_a_v_codec_context.html#a0a905e1ec6b03f69f60a4e668561d677">execute()</a> to store some per <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> stuff.</p>
<ul>
<li>encoding: set by <a class="el" href="struct_a_v_codec_context.html#a0a905e1ec6b03f69f60a4e668561d677">execute()</a></li>
<li>decoding: set by <a class="el" href="struct_a_v_codec_context.html#a0a905e1ec6b03f69f60a4e668561d677">execute()</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="a5bd9a6f252d615243d01198fd3957fd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::thread_safe_callbacks</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set by the client if its custom get_buffer() callback can be called synchronously from another thread, which allows faster multithreaded decoding. <a class="el" href="struct_a_v_codec_context.html#aa6e68a5af5b69e58c6b033a9e3ea007f">draw_horiz_band()</a> will be called from other threads regardless of this setting. Ignored if the default get_buffer() is used.</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by user. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7651614f4309122981d70e06a4b42fcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::thread_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Which multithreading methods to use. Use of FF_THREAD_FRAME will increase decoding delay by one frame per thread, so clients which cannot provide future frames should not use it.</p>
<ul>
<li>encoding: Set by user, otherwise the default is used.</li>
<li>decoding: Set by user, otherwise the default is used. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5c62b9c1528a272923ea2a4b86dea31a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::ticks_per_frame</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For some codecs, the time base is closer to the field rate than the frame rate. Most notably, H.264 and MPEG-2 specify time_base as half of frame duration if no telecine is used ...</p>
<p>Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2. </p>

</div>
</div>
<a class="anchor" id="ab7bfeb9fa5840aac090e2b0bd0ef7589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_v_rational.html">AVRational</a> AVCodecContext::time_base</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the fundamental unit of time (in seconds) in terms of which frame timestamps are represented. For fixed-fps content, timebase should be 1/framerate and timestamp increments should be identically 1.</p>
<ul>
<li>encoding: MUST be set by user.</li>
<li>decoding: Set by libavcodec. </li>
</ul>

</div>
</div>
<a class="anchor" id="a18c0dc7988a2d4ff291980001e0ceef9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t AVCodecContext::timecode_frame_start</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GOP timecode frame start number, in non drop frame format</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a025940af0d5249418d6ac7e183fdd40f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::trellis</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>trellis RD quantization</p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: unused </li>
</ul>

</div>
</div>
<a class="anchor" id="a35469829873ff8e5444040323e8e1e59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t AVCodecContext::vbv_delay</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VBV delay coded in the last frame (in periods of a 27 MHz clock). Used for compliant TS muxing.</p>
<ul>
<li>encoding: Set by libavcodec.</li>
<li>decoding: unused. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0d8f46461754e8abea0847dcbc41b956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::width</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>picture width / height.</p>
<ul>
<li>encoding: MUST be set by user.</li>
<li>decoding: May be set by the user before opening the decoder if known e.g. from the container. Some decoders will require the dimensions to be set by the caller. During decoding, the decoder may overwrite those values as required. </li>
</ul>

</div>
</div>
<a class="anchor" id="a4649a6454a0f784794b89afdc44da669"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::workaround_bugs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Work around bugs in encoders which sometimes cannot be detected automatically.</p>
<ul>
<li>encoding: Set by user</li>
<li>decoding: Set by user </li>
</ul>

</div>
</div>
<a class="anchor" id="a13c6160724b39b5dc0a3994eaab5a3a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVCodecContext::xvmc_acceleration</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>XVideo Motion Acceleration</p>
<ul>
<li>encoding: forbidden</li>
<li>decoding: set by decoder </li>
</ul>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="avcodec_8h_source.html">avcodec.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a></li>
    <li class="footer">Generated on Sat Jan 11 2014 18:32:16 for ofxLibav by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
